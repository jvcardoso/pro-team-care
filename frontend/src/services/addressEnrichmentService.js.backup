/**
 * Servico para enriquecer dados de endereco usando ViaCEP e geocoding
 * Complementa dados basicos do CNPJ com informacoes completas
 */

import geocodingService from './geocodingService';

/**
 * Mapeamento de UF para c√≥digo IBGE do estado
 */
const IBGE_STATE_CODES = {
  'AC': 12, 'AL': 27, 'AP': 16, 'AM': 13, 'BA': 29, 'CE': 23,
  'DF': 53, 'ES': 32, 'GO': 52, 'MA': 21, 'MT': 51, 'MS': 50,
  'MG': 31, 'PA': 15, 'PB': 25, 'PR': 41, 'PE': 26, 'PI': 22,
  'RJ': 33, 'RN': 24, 'RS': 43, 'RO': 11, 'RR': 14, 'SC': 42,
  'SP': 35, 'SE': 28, 'TO': 17
};

/**
 * Converte UF para c√≥digo IBGE do estado
 * @param {string} uf - Unidade Federativa (ex: 'SP', 'RJ')
 * @returns {number|null} C√≥digo IBGE do estado ou null se inv√°lido
 */
function getIbgeStateCode(uf) {
  if (!uf || typeof uf !== 'string') return null;
  const upperUf = uf.toUpperCase();
  return IBGE_STATE_CODES[upperUf] || null;
}

/**
 * Classe para enriquecer dados de endere√ßo
 */
class AddressEnrichmentService {
  constructor() {
    this.cache = new Map(); // Cache para evitar consultas repetidas
  }

  /**
   * Consulta ViaCEP para obter dados completos do endere√ßo
   * @param {string} cep - CEP limpo (8 d√≠gitos)
   * @returns {Promise<Object|null>} Dados do ViaCEP ou null se erro
   */
  async consultarViaCEP(cep) {
    if (!cep || cep.length !== 8) {
      console.warn('CEP inv√°lido para consulta ViaCEP:', cep);
      return null;
    }

    // Verificar cache
    const cacheKey = `viacep_${cep}`;
    if (this.cache.has(cacheKey)) {
      console.log('üîÑ Usando ViaCEP do cache:', cep);
      return this.cache.get(cacheKey);
    }

    try {
      console.log('üìç Consultando ViaCEP:', cep);

      const response = await fetch(`https://viacep.com.br/ws/${cep}/json/`, {
        timeout: 10000 // 10 segundos de timeout
      });

      if (!response.ok) {
        throw new Error(`ViaCEP API error: ${response.status}`);
      }

      const data = await response.json();

      if (data.erro) {
        console.warn('CEP n√£o encontrado no ViaCEP:', cep);
        return null;
      }

      // Salvar no cache
      this.cache.set(cacheKey, data);

      return data;
    } catch (error) {
      console.error('Erro ao consultar ViaCEP:', error);
      return null;
    }
  }

  /**
   * Enriquecer endere√ßo com dados do ViaCEP
   * @param {Object} addressData - Dados b√°sicos do endere√ßo
   * @returns {Promise<Object>} Dados enriquecidos
   */
  async enriquecerComViaCEP(addressData) {
    if (!addressData || !addressData.zip_code) {
      console.warn('Dados de endere√ßo insuficientes para enriquecimento:', addressData);
      throw new Error('Dados de endere√ßo insuficientes para enriquecimento');
    }

    const cep = addressData.zip_code.replace(/\D/g, '');

    if (cep.length !== 8) {
      console.warn('CEP inv√°lido para enriquecimento:', cep);
      throw new Error('CEP inv√°lido para enriquecimento');
    }

    try {
      const viaCepData = await this.consultarViaCEP(cep);

      if (!viaCepData) {
        console.warn('ViaCEP n√£o retornou dados para CEP:', cep);
        throw new Error('CEP n√£o encontrado no ViaCEP');
      }

      // Verificar se ViaCEP retornou dados v√°lidos
      if (!viaCepData.logradouro && !viaCepData.bairro && !viaCepData.localidade) {
        console.warn('ViaCEP retornou dados incompletos:', viaCepData);
        throw new Error('Dados incompletos retornados pelo ViaCEP');
      }

      // Mesclar dados do ViaCEP com dados existentes
      const enrichedAddress = {
        ...addressData,
        // Dados b√°sicos do endere√ßo
        street: viaCepData.logradouro || addressData.street || '',
        neighborhood: viaCepData.bairro || addressData.neighborhood || '',
        city: viaCepData.localidade || addressData.city || '',
        state: viaCepData.uf || addressData.state || '',
        details: viaCepData.complemento || addressData.details || '',

        // C√≥digos oficiais brasileiros do ViaCEP
        ibge_city_code: viaCepData.ibge ? parseInt(viaCepData.ibge) : addressData.ibge_city_code,
        gia_code: viaCepData.gia || addressData.gia_code,
        siafi_code: viaCepData.siafi || addressData.siafi_code,
        area_code: viaCepData.ddd || addressData.area_code,

        // Inferir c√≥digo IBGE do estado baseado no UF
        ibge_state_code: viaCepData.uf ? getIbgeStateCode(viaCepData.uf) : addressData.ibge_state_code,

        // Manter campos originais se ViaCEP n√£o tiver
        zip_code: addressData.zip_code, // Manter formato original
        country: addressData.country || 'BR',
        type: addressData.type || 'commercial',
        is_principal: addressData.is_principal !== undefined ? addressData.is_principal : true,

        // Criar datas naive (sem timezone) para o banco
        const now = new Date();
        const naiveDateTime = new Date(now.getTime() - (now.getTimezoneOffset() * 60000)).toISOString();

        // Adicionar metadados de valida√ß√£o
        const enrichedAddress = {
          ...addressData,
          // Dados b√°sicos do endere√ßo
          street: viaCepData.logradouro || addressData.street || '',
          neighborhood: viaCepData.bairro || addressData.neighborhood || '',
          city: viaCepData.localidade || addressData.city || '',
          state: viaCepData.uf || addressData.state || '',
          details: viaCepData.complemento || addressData.details || '',

          // C√≥digos oficiais brasileiros do ViaCEP
          ibge_city_code: viaCepData.ibge ? parseInt(viaCepData.ibge) : addressData.ibge_city_code,
          gia_code: viaCepData.gia || addressData.gia_code,
          siafi_code: viaCepData.siafi || addressData.siafi_code,
          area_code: viaCepData.ddd || addressData.area_code,

          // Inferir c√≥digo IBGE do estado baseado no UF
          ibge_state_code: viaCepData.uf ? getIbgeStateCode(viaCepData.uf) : addressData.ibge_state_code,

          // Manter campos originais se ViaCEP n√£o tiver
          zip_code: addressData.zip_code, // Manter formato original
          country: addressData.country || 'BR',
          type: addressData.type || 'commercial',
          is_principal: addressData.is_principal !== undefined ? addressData.is_principal : true,

          // Adicionar metadados de valida√ß√£o com datas naive
          enriched_at: naiveDateTime,
          enrichment_source: 'viacep',
          validation_source: 'viacep',
          last_validated_at: naiveDateTime,
          is_validated: true,

          // Armazenar dados completos do ViaCEP para refer√™ncia futura
          via_cep_data: viaCepData
        };

      console.log('‚úÖ Endere√ßo enriquecido com ViaCEP:', enrichedAddress);
      return enrichedAddress;

    } catch (error) {
      console.error('Erro ao enriquecer endere√ßo com ViaCEP:', error);

      // Re-throw com mensagem mais espec√≠fica
      if (error.message.includes('ViaCEP')) {
        throw error;
      } else {
        throw new Error(`Erro ao consultar ViaCEP: ${error.message}`);
      }
    }
  }

  /**
   * Adicionar coordenadas geogr√°ficas ao endere√ßo
   * @param {Object} addressData - Dados do endere√ßo
   * @returns {Promise<Object>} Dados com coordenadas
   */
  async adicionarCoordenadas(addressData) {
    if (!addressData) {
      return addressData;
    }

    try {
      // Construir endere√ßo completo para geocoding
      const addressParts = [
        addressData.street,
        addressData.number,
        addressData.neighborhood,
        addressData.city,
        addressData.state,
        'Brasil'
      ].filter(Boolean);

      const fullAddress = addressParts.join(', ');

      if (!fullAddress.trim()) {
        console.warn('Endere√ßo insuficiente para geocoding:', addressData);
        return addressData;
      }

      console.log('üó∫Ô∏è Solicitando geocoding para:', fullAddress);

      const geoData = await geocodingService.geocode(fullAddress);

      if (!geoData) {
        console.warn('Geocoding n√£o retornou coordenadas para:', fullAddress);
        return addressData;
      }

      // Criar data naive para o banco
      const now = new Date();
      const naiveDateTime = new Date(now.getTime() - (now.getTimezoneOffset() * 60000)).toISOString();

      // Adicionar coordenadas aos dados do endere√ßo
      const addressWithCoordinates = {
        ...addressData,
        latitude: geoData.latitude,
        longitude: geoData.longitude,
        geocoding_accuracy: geoData.geocoding_accuracy,
        geocoding_source: geoData.geocoding_source,
        formatted_address: geoData.formatted_address,
        coordinates_added_at: naiveDateTime,
        coordinates_source: 'nominatim'
      };

      console.log('‚úÖ Coordenadas adicionadas:', {
        latitude: geoData.latitude,
        longitude: geoData.longitude,
        accuracy: geoData.geocoding_accuracy
      });

      return addressWithCoordinates;

    } catch (error) {
      console.error('Erro ao adicionar coordenadas:', error);
      return addressData;
    }
  }

  /**
   * Enriquecer endere√ßo completo (ViaCEP + geocoding)
   * @param {Object} addressData - Dados b√°sicos do endere√ßo
   * @returns {Promise<Object>} Dados completamente enriquecidos
   */
  async enriquecerEnderecoCompleto(addressData) {
    if (!addressData) {
      return addressData;
    }

    console.log('üöÄ Iniciando enriquecimento completo do endere√ßo:', addressData);

    try {
      // Primeiro: enriquecer com ViaCEP
      const viaCepEnriched = await this.enriquecerComViaCEP(addressData);

      // Segundo: adicionar coordenadas
      const fullyEnriched = await this.adicionarCoordenadas(viaCepEnriched);

      console.log('üéâ Endere√ßo completamente enriquecido:', fullyEnriched);
      return fullyEnriched;

    } catch (error) {
      console.error('Erro no enriquecimento completo do endere√ßo:', error);
      return addressData;
    }
  }

  /**
   * Enriquecer m√∫ltiplos endere√ßos
   * @param {Array} addresses - Lista de endere√ßos
   * @returns {Promise<Array>} Lista de endere√ßos enriquecidos
   */
  async enriquecerMultiplosEnderecos(addresses) {
    if (!Array.isArray(addresses) || addresses.length === 0) {
      return addresses;
    }

    console.log(`üìã Enriquecendo ${addresses.length} endere√ßos...`);

    const enrichedAddresses = await Promise.all(
      addresses.map(async (address, index) => {
        try {
          console.log(`üîÑ Enriquecendo endere√ßo ${index + 1}/${addresses.length}`);
          return await this.enriquecerEnderecoCompleto(address);
        } catch (error) {
          console.error(`Erro ao enriquecer endere√ßo ${index + 1}:`, error);
          return address; // Retornar endere√ßo original em caso de erro
        }
      })
    );

    console.log('‚úÖ Todos os endere√ßos foram processados');
    return enrichedAddresses;
  }

  /**
   * Limpar cache (√∫til para desenvolvimento)
   */
  clearCache() {
    this.cache.clear();
    console.log('üßπ Cache do servi√ßo de enriquecimento limpo');
  }
}

// Inst√¢ncia singleton
const addressEnrichmentService = new AddressEnrichmentService();

export default addressEnrichmentService;