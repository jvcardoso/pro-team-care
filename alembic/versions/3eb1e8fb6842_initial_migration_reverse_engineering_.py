"""Initial migration - reverse engineering existing database

Revision ID: 3eb1e8fb6842
Revises:
Create Date: 2025-08-29 14:50:46.653101

"""

from typing import Sequence, Union

import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

from alembic import op

# revision identifiers, used by Alembic.
revision: str = "3eb1e8fb6842"
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(
        op.f("company_settings_company_id_index"), table_name="company_settings"
    )
    op.drop_index(
        op.f("company_settings_setting_category_index"), table_name="company_settings"
    )
    op.drop_index(
        op.f("company_settings_setting_key_index"), table_name="company_settings"
    )
    op.drop_index(
        op.f("company_settings_setting_value_fulltext"),
        table_name="company_settings",
        postgresql_using="gin",
    )
    op.drop_index(
        op.f("company_settings_updated_by_user_id_index"), table_name="company_settings"
    )
    op.drop_table("company_settings")
    op.drop_index(op.f("master_jobs_queue_index"), table_name="jobs")
    op.drop_table("jobs")
    op.drop_index(op.f("idx_query_logs_sensitivity"), table_name="query_audit_logs")
    op.drop_index(op.f("idx_query_logs_table_time"), table_name="query_audit_logs")
    op.drop_index(op.f("idx_query_logs_timestamp"), table_name="query_audit_logs")
    op.drop_index(op.f("idx_query_logs_user_time"), table_name="query_audit_logs")
    op.drop_index(
        op.f("master_query_audit_logs_session_id_index"), table_name="query_audit_logs"
    )
    op.drop_index(
        op.f("master_query_audit_logs_table_accessed_index"),
        table_name="query_audit_logs",
    )
    op.drop_index(
        op.f("master_query_audit_logs_user_id_index"), table_name="query_audit_logs"
    )
    op.drop_table("query_audit_logs")
    op.drop_index(
        op.f("activity_logs_2025_08_causer_type_causer_id_index"),
        table_name="activity_logs_2025_08",
    )
    op.drop_index(
        op.f("activity_logs_2025_08_created_at_index"),
        table_name="activity_logs_2025_08",
    )
    op.drop_index(
        op.f("activity_logs_2025_08_log_name_index"), table_name="activity_logs_2025_08"
    )
    op.drop_index(
        op.f("activity_logs_2025_08_subject_type_subject_id_index"),
        table_name="activity_logs_2025_08",
    )
    op.drop_table("activity_logs_2025_08")
    op.drop_index(
        op.f("sessions_last_activity_index"), table_name="sessions", schema="public"
    )
    op.drop_index(
        op.f("sessions_user_id_index"), table_name="sessions", schema="public"
    )
    op.drop_table("sessions", schema="public")
    op.drop_index(
        op.f("tenant_features_expires_at_index"), table_name="tenant_features"
    )
    op.drop_index(
        op.f("tenant_features_feature_config_fulltext"),
        table_name="tenant_features",
        postgresql_using="gin",
    )
    op.drop_index(
        op.f("tenant_features_feature_key_index"), table_name="tenant_features"
    )
    op.drop_index(
        op.f("tenant_features_tenant_type_tenant_id_index"),
        table_name="tenant_features",
    )
    op.drop_index(
        op.f("tenant_features_tenant_type_tenant_id_is_enabled_index"),
        table_name="tenant_features",
    )
    op.drop_table("tenant_features")
    op.drop_index(op.f("people_deleted_at_index"), table_name="people")
    op.drop_index(
        op.f("people_metadata_fulltext"), table_name="people", postgresql_using="gin"
    )
    op.drop_index(op.f("people_name_index"), table_name="people")
    op.drop_index(op.f("people_person_type_index"), table_name="people")
    op.drop_index(op.f("people_status_index"), table_name="people")
    op.drop_table("people")
    op.drop_table("cache_locks")
    op.drop_index(op.f("permissions_context_level_index"), table_name="permissions")
    op.drop_index(op.f("permissions_is_active_index"), table_name="permissions")
    op.drop_index(op.f("permissions_module_action_index"), table_name="permissions")
    op.drop_index(op.f("permissions_module_index"), table_name="permissions")
    op.drop_index(op.f("permissions_name_is_active_index"), table_name="permissions")
    op.drop_table("permissions")
    op.drop_index(
        op.f("role_permissions_granted_at_index"), table_name="role_permissions"
    )
    op.drop_index(
        op.f("role_permissions_granted_by_user_id_index"), table_name="role_permissions"
    )
    op.drop_index(
        op.f("role_permissions_permission_id_index"), table_name="role_permissions"
    )
    op.drop_index(op.f("role_permissions_role_id_index"), table_name="role_permissions")
    op.drop_table("role_permissions")
    op.drop_index(op.f("establishments_company_id_index"), table_name="establishments")
    op.drop_index(
        op.f("establishments_company_id_is_principal_index"),
        table_name="establishments",
    )
    op.drop_index(op.f("establishments_deleted_at_index"), table_name="establishments")
    op.drop_index(op.f("establishments_person_id_index"), table_name="establishments")
    op.drop_table("establishments")
    op.drop_index(
        op.f("consent_records_consent_type_index"), table_name="consent_records"
    )
    op.drop_index(
        op.f("consent_records_person_id_consent_type_index"),
        table_name="consent_records",
    )
    op.drop_index(op.f("consent_records_person_id_index"), table_name="consent_records")
    op.drop_index(op.f("consent_records_status_index"), table_name="consent_records")
    op.drop_index(op.f("idx_consent_explicit"), table_name="consent_records")
    op.drop_index(op.f("idx_consent_interface"), table_name="consent_records")
    op.drop_table("consent_records")
    op.drop_table("migrations", schema="public")
    op.drop_index(
        op.f("idx_addresses_api_data_gin"),
        table_name="addresses",
        postgresql_using="gin",
    )
    op.drop_index(op.f("idx_addresses_area_code"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_city_state"), table_name="addresses")
    op.drop_index(
        op.f("idx_addresses_coordinates"),
        table_name="addresses",
        postgresql_where="((latitude IS NOT NULL) AND (longitude IS NOT NULL))",
    )
    op.drop_index(op.f("idx_addresses_coverage"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_deleted_at"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_distance"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_google_place_id"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_ibge_codes"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_polymorphic"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_principal"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_quality_score"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_region"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_validated"), table_name="addresses")
    op.drop_index(op.f("idx_addresses_zip_code"), table_name="addresses")
    op.drop_index(op.f("master_addresses_deleted_at_index"), table_name="addresses")
    op.drop_table("addresses")
    op.drop_index(op.f("emails_deleted_at_index"), table_name="emails")
    op.drop_index(op.f("emails_email_address_index"), table_name="emails")
    op.drop_index(op.f("emails_emailable_type_emailable_id_index"), table_name="emails")
    op.drop_table("emails")
    op.drop_table("job_batches")
    op.drop_table("failed_jobs")
    op.drop_index(
        op.f("data_privacy_logs_created_at_index"), table_name="data_privacy_logs"
    )
    op.drop_index(
        op.f("data_privacy_logs_is_sensitive_data_created_at_index"),
        table_name="data_privacy_logs",
    )
    op.drop_index(
        op.f("data_privacy_logs_operation_type_index"), table_name="data_privacy_logs"
    )
    op.drop_index(
        op.f("data_privacy_logs_operator_id_index"), table_name="data_privacy_logs"
    )
    op.drop_index(
        op.f("data_privacy_logs_person_id_index"), table_name="data_privacy_logs"
    )
    op.drop_table("data_privacy_logs")
    op.drop_index(
        op.f("menus_allowed_companies_fulltext"),
        table_name="menus",
        postgresql_using="gin",
    )
    op.drop_index(
        op.f("menus_allowed_establishments_fulltext"),
        table_name="menus",
        postgresql_using="gin",
    )
    op.drop_index(op.f("menus_deleted_at_index"), table_name="menus")
    op.drop_index(op.f("menus_dev_only_index"), table_name="menus")
    op.drop_index(op.f("menus_is_active_is_visible_index"), table_name="menus")
    op.drop_index(op.f("menus_level_index"), table_name="menus")
    op.drop_index(op.f("menus_level_sort_order_index"), table_name="menus")
    op.drop_index(op.f("menus_parent_id_index"), table_name="menus")
    op.drop_index(op.f("menus_parent_id_sort_order_index"), table_name="menus")
    op.drop_index(op.f("menus_path_index"), table_name="menus")
    op.drop_index(op.f("menus_permission_name_index"), table_name="menus")
    op.drop_index(
        op.f("menus_required_permissions_fulltext"),
        table_name="menus",
        postgresql_using="gin",
    )
    op.drop_index(
        op.f("menus_required_roles_fulltext"),
        table_name="menus",
        postgresql_using="gin",
    )
    op.drop_index(op.f("menus_route_name_index"), table_name="menus")
    op.drop_index(op.f("menus_sort_order_index"), table_name="menus")
    op.drop_index(op.f("menus_visible_in_menu_index"), table_name="menus")
    op.drop_table("menus")
    op.drop_index(
        op.f("master_lgpd_audit_config_table_name_index"),
        table_name="lgpd_audit_config",
    )
    op.drop_table("lgpd_audit_config")
    op.drop_index(op.f("companies_deleted_at_index"), table_name="companies")
    op.drop_index(
        op.f("companies_metadata_fulltext"),
        table_name="companies",
        postgresql_using="gin",
    )
    op.drop_index(op.f("companies_person_id_index"), table_name="companies")
    op.drop_index(
        op.f("companies_settings_fulltext"),
        table_name="companies",
        postgresql_using="gin",
    )
    op.drop_table("companies")
    op.drop_table("cache")
    op.drop_index(op.f("phones_accepts_whatsapp_marketing_index"), table_name="phones")
    op.drop_index(
        op.f("phones_api_data_fulltext"), table_name="phones", postgresql_using="gin"
    )
    op.drop_index(op.f("phones_carrier_index"), table_name="phones")
    op.drop_index(op.f("phones_deleted_at_index"), table_name="phones")
    op.drop_index(op.f("phones_is_whatsapp_index"), table_name="phones")
    op.drop_index(op.f("phones_number_index"), table_name="phones")
    op.drop_index(op.f("phones_phoneable_type_phoneable_id_index"), table_name="phones")
    op.drop_index(
        op.f("phones_phoneable_type_phoneable_id_whatsapp_formatted_index"),
        table_name="phones",
    )
    op.drop_index(op.f("phones_verified_at_index"), table_name="phones")
    op.drop_index(op.f("phones_whatsapp_business_index"), table_name="phones")
    op.drop_index(op.f("phones_whatsapp_formatted_index"), table_name="phones")
    op.drop_index(
        op.f("phones_whatsapp_verified_whatsapp_verified_at_index"), table_name="phones"
    )
    op.drop_table("phones")
    op.drop_index(
        op.f("user_contexts_context_type_context_id_index"), table_name="user_contexts"
    )
    op.drop_index(op.f("user_contexts_session_id_index"), table_name="user_contexts")
    op.drop_index(op.f("user_contexts_switched_at_index"), table_name="user_contexts")
    op.drop_index(op.f("user_contexts_user_id_index"), table_name="user_contexts")
    op.drop_index(
        op.f("user_contexts_user_id_session_id_index"), table_name="user_contexts"
    )
    op.drop_table("user_contexts")
    op.drop_index(op.f("idx_incidents_occurred"), table_name="lgpd_incidents")
    op.drop_index(op.f("idx_incidents_status"), table_name="lgpd_incidents")
    op.drop_index(op.f("idx_incidents_type_severity"), table_name="lgpd_incidents")
    op.drop_table("lgpd_incidents")
    op.drop_index(op.f("professionals_deleted_at_index"), table_name="professionals")
    op.drop_index(
        op.f("professionals_establishment_id_index"), table_name="professionals"
    )
    op.drop_index(op.f("professionals_pf_person_id_index"), table_name="professionals")
    op.drop_index(op.f("professionals_pj_person_id_index"), table_name="professionals")
    op.drop_index(
        op.f("professionals_specialties_fulltext"),
        table_name="professionals",
        postgresql_using="gin",
    )
    op.drop_index(op.f("professionals_status_index"), table_name="professionals")
    op.drop_table("professionals")
    op.drop_index(op.f("sessions_last_activity_index"), table_name="sessions")
    op.drop_index(op.f("sessions_user_id_index"), table_name="sessions")
    op.drop_table("sessions")
    op.drop_index(
        op.f("establishment_settings_establishment_id_index"),
        table_name="establishment_settings",
    )
    op.drop_index(
        op.f("establishment_settings_setting_category_index"),
        table_name="establishment_settings",
    )
    op.drop_index(
        op.f("establishment_settings_setting_key_index"),
        table_name="establishment_settings",
    )
    op.drop_index(
        op.f("establishment_settings_setting_value_fulltext"),
        table_name="establishment_settings",
        postgresql_using="gin",
    )
    op.drop_table("establishment_settings")
    op.drop_index(
        op.f("user_roles_context_type_context_id_index"), table_name="user_roles"
    )
    op.drop_index(op.f("user_roles_deleted_at_index"), table_name="user_roles")
    op.drop_index(op.f("user_roles_role_id_index"), table_name="user_roles")
    op.drop_index(
        op.f("user_roles_user_id_context_type_context_id_index"),
        table_name="user_roles",
    )
    op.drop_index(op.f("user_roles_user_id_index"), table_name="user_roles")
    op.drop_table("user_roles")
    op.drop_table("password_reset_tokens")
    op.drop_index(
        op.f("activity_logs_causer_type_causer_id_index"), table_name="activity_logs"
    )
    op.drop_index(op.f("activity_logs_created_at_index"), table_name="activity_logs")
    op.drop_index(op.f("activity_logs_log_name_index"), table_name="activity_logs")
    op.drop_index(
        op.f("activity_logs_subject_type_subject_id_index"), table_name="activity_logs"
    )
    op.drop_index(op.f("idx_activity_logs_audit"), table_name="activity_logs")
    op.drop_index(op.f("idx_activity_logs_basis"), table_name="activity_logs")
    op.drop_index(op.f("idx_activity_logs_ip"), table_name="activity_logs")
    op.drop_index(op.f("idx_activity_logs_sensitivity"), table_name="activity_logs")
    op.drop_index(op.f("idx_activity_logs_session"), table_name="activity_logs")
    op.drop_table("activity_logs")
    op.drop_index(op.f("clients_deleted_at_index"), table_name="clients")
    op.drop_index(op.f("clients_establishment_id_index"), table_name="clients")
    op.drop_index(op.f("clients_person_id_index"), table_name="clients")
    op.drop_index(op.f("clients_status_index"), table_name="clients")
    op.drop_table("clients")
    op.drop_index(
        op.f("idx_user_establishments_deleted_at"), table_name="user_establishments"
    )
    op.drop_index(
        op.f("idx_user_establishments_establishment_id"),
        table_name="user_establishments",
        postgresql_where="(deleted_at IS NULL)",
    )
    op.drop_index(
        op.f("idx_user_establishments_primary"),
        table_name="user_establishments",
        postgresql_where="((is_primary = true) AND (deleted_at IS NULL))",
    )
    op.drop_index(
        op.f("idx_user_establishments_status"),
        table_name="user_establishments",
        postgresql_where="(deleted_at IS NULL)",
    )
    op.drop_index(
        op.f("idx_user_establishments_user_id"),
        table_name="user_establishments",
        postgresql_where="(deleted_at IS NULL)",
    )
    op.drop_table("user_establishments")
    op.drop_table("migrations")
    op.drop_table("alembic_version")
    op.drop_index(op.f("roles_context_type_index"), table_name="roles")
    op.drop_index(op.f("roles_is_active_index"), table_name="roles")
    op.drop_index(op.f("roles_is_system_role_index"), table_name="roles")
    op.drop_index(op.f("roles_level_index"), table_name="roles")
    op.drop_index(op.f("roles_name_is_active_index"), table_name="roles")
    op.drop_index(
        op.f("roles_settings_fulltext"), table_name="roles", postgresql_using="gin"
    )
    op.drop_table("roles")
    op.drop_index(op.f("documents_deleted_at_index"), table_name="documents")
    op.drop_index(
        op.f("documents_documentable_type_documentable_id_index"),
        table_name="documents",
    )
    op.drop_index(op.f("documents_expires_at_index"), table_name="documents")
    op.drop_index(op.f("documents_file_hash_sha256_index"), table_name="documents")
    op.drop_index(
        op.f("documents_tags_fulltext"), table_name="documents", postgresql_using="gin"
    )
    op.drop_index(op.f("documents_type_index"), table_name="documents")
    op.drop_table("documents")
    op.alter_column(
        "users",
        "person_id",
        existing_type=sa.BIGINT(),
        comment=None,
        existing_comment='Referência (FK) para o registro correspondente na tabela "people".',
        existing_nullable=False,
    )
    op.alter_column(
        "users",
        "email_address",
        existing_type=sa.VARCHAR(length=255),
        comment=None,
        existing_comment="Email único para login e comunicação, associado a esta conta.",
        existing_nullable=False,
    )
    op.alter_column(
        "users",
        "is_system_admin",
        existing_type=sa.BOOLEAN(),
        comment=None,
        existing_comment="Flag para super administradores do sistema (privilégio da conta, não da pessoa).",
        existing_nullable=True,
        existing_server_default=sa.text("false"),
    )
    op.alter_column(
        "users",
        "preferences",
        existing_type=postgresql.JSONB(astext_type=sa.Text()),
        comment=None,
        existing_comment="Preferências de interface e uso do sistema para esta conta.",
        existing_nullable=True,
    )
    op.drop_index(op.f("users_deleted_at_index"), table_name="users")
    op.drop_constraint(op.f("users_email_address_unique"), "users", type_="unique")
    op.drop_index(op.f("users_is_system_admin_index"), table_name="users")
    op.drop_index(op.f("users_person_id_index"), table_name="users")
    op.drop_constraint(op.f("users_person_id_unique"), "users", type_="unique")
    op.create_index(
        op.f("ix_master_users_email_address"),
        "users",
        ["email_address"],
        unique=True,
        schema="master",
    )
    op.create_index(
        op.f("ix_master_users_id"), "users", ["id"], unique=False, schema="master"
    )
    op.drop_constraint(op.f("fk_users_person"), "users", type_="foreignkey")
    op.drop_table_comment(
        "users",
        existing_comment="Tabela de Contas de Acesso. Armazena credenciais e configurações para login no sistema.",
        schema=None,
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table_comment(
        "users",
        "Tabela de Contas de Acesso. Armazena credenciais e configurações para login no sistema.",
        existing_comment=None,
        schema=None,
    )
    op.create_foreign_key(
        op.f("fk_users_person"),
        "users",
        "people",
        ["person_id"],
        ["id"],
        ondelete="CASCADE",
    )
    op.drop_index(op.f("ix_master_users_id"), table_name="users", schema="master")
    op.drop_index(
        op.f("ix_master_users_email_address"), table_name="users", schema="master"
    )
    op.create_unique_constraint(
        op.f("users_person_id_unique"),
        "users",
        ["person_id"],
        postgresql_nulls_not_distinct=False,
    )
    op.create_index(op.f("users_person_id_index"), "users", ["person_id"], unique=False)
    op.create_index(
        op.f("users_is_system_admin_index"), "users", ["is_system_admin"], unique=False
    )
    op.create_unique_constraint(
        op.f("users_email_address_unique"),
        "users",
        ["email_address"],
        postgresql_nulls_not_distinct=False,
    )
    op.create_index(
        op.f("users_deleted_at_index"), "users", ["deleted_at"], unique=False
    )
    op.alter_column(
        "users",
        "preferences",
        existing_type=postgresql.JSONB(astext_type=sa.Text()),
        comment="Preferências de interface e uso do sistema para esta conta.",
        existing_nullable=True,
    )
    op.alter_column(
        "users",
        "is_system_admin",
        existing_type=sa.BOOLEAN(),
        comment="Flag para super administradores do sistema (privilégio da conta, não da pessoa).",
        existing_nullable=True,
        existing_server_default=sa.text("false"),
    )
    op.alter_column(
        "users",
        "email_address",
        existing_type=sa.VARCHAR(length=255),
        comment="Email único para login e comunicação, associado a esta conta.",
        existing_nullable=False,
    )
    op.alter_column(
        "users",
        "person_id",
        existing_type=sa.BIGINT(),
        comment='Referência (FK) para o registro correspondente na tabela "people".',
        existing_nullable=False,
    )
    op.create_table(
        "documents",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "documentable_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="O nome da classe do modelo proprietário do documento (ex: App\\\\Models\\\\Company).",
        ),
        sa.Column(
            "documentable_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="O ID do registro proprietário do documento.",
        ),
        sa.Column(
            "type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Tipo do documento: cnpj, cpf, contract, etc.",
        ),
        sa.Column("title", sa.VARCHAR(length=200), autoincrement=False, nullable=False),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "filename", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "original_filename",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "mime_type", sa.VARCHAR(length=100), autoincrement=False, nullable=False
        ),
        sa.Column("file_size_bytes", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column(
            "file_path", sa.VARCHAR(length=500), autoincrement=False, nullable=False
        ),
        sa.Column(
            "file_hash_sha256",
            sa.VARCHAR(length=64),
            autoincrement=False,
            nullable=False,
            comment="Hash SHA-256 do arquivo para verificação de integridade.",
        ),
        sa.Column(
            "category", sa.VARCHAR(length=50), autoincrement=False, nullable=True
        ),
        sa.Column(
            "tags",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_public",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_required",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "expires_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "contains_personal_data",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Indica se o documento contém dados pessoais (LGPD).",
        ),
        sa.Column(
            "data_retention_expires_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "uploaded_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "documentable_type::text = ANY (ARRAY['App\\Models\\Company'::character varying::text, 'App\\Models\\Establishment'::character varying::text, 'App\\Models\\Professional'::character varying::text, 'App\\Models\\People'::character varying::text])",
            name=op.f("documents_documentable_type_check"),
        ),
        sa.CheckConstraint(
            "type::text = ANY (ARRAY['cnpj'::character varying::text, 'contrato_social'::character varying::text, 'inscricao_estadual'::character varying::text, 'inscricao_municipal'::character varying::text, 'cpf'::character varying::text, 'rg'::character varying::text, 'photo'::character varying::text, 'diploma'::character varying::text, 'certificate'::character varying::text, 'cnh'::character varying::text, 'alvara'::character varying::text, 'licenca'::character varying::text, 'procuracao'::character varying::text, 'contract'::character varying::text, 'proposal'::character varying::text, 'budget'::character varying::text, 'invoice'::character varying::text, 'report'::character varying::text, 'medical_report'::character varying::text, 'exam'::character varying::text, 'prescription'::character varying::text, 'other'::character varying::text])",
            name=op.f("documents_type_check"),
        ),
        sa.ForeignKeyConstraint(
            ["uploaded_by_user_id"],
            ["users.id"],
            name=op.f("fk_documents_uploaded_by"),
            ondelete="SET NULL",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("documents_pkey")),
        comment="Documentos e anexos polimórficos para as entidades do sistema.",
    )
    op.create_index(op.f("documents_type_index"), "documents", ["type"], unique=False)
    op.create_index(
        op.f("documents_tags_fulltext"),
        "documents",
        [sa.literal_column("to_tsvector('english'::regconfig, tags)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("documents_file_hash_sha256_index"),
        "documents",
        ["file_hash_sha256"],
        unique=False,
    )
    op.create_index(
        op.f("documents_expires_at_index"), "documents", ["expires_at"], unique=False
    )
    op.create_index(
        op.f("documents_documentable_type_documentable_id_index"),
        "documents",
        ["documentable_type", "documentable_id"],
        unique=False,
    )
    op.create_index(
        op.f("documents_deleted_at_index"), "documents", ["deleted_at"], unique=False
    )
    op.create_table(
        "roles",
        sa.Column(
            "id",
            sa.BIGINT(),
            server_default=sa.text("nextval('roles_id_seq'::regclass)"),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column(
            "name",
            sa.VARCHAR(length=125),
            autoincrement=False,
            nullable=False,
            comment="Nome único do papel em snake_case",
        ),
        sa.Column(
            "display_name",
            sa.VARCHAR(length=200),
            autoincrement=False,
            nullable=False,
            comment="Nome amigável para exibição",
        ),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "level",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
            comment="Nível hierárquico do papel (0-100)",
        ),
        sa.Column(
            "context_type",
            sa.VARCHAR(length=255),
            server_default=sa.text("'establishment'::character varying"),
            autoincrement=False,
            nullable=False,
            comment="Contexto do papel: system, company, establishment",
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_system_role",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Indica se é um papel padrão do sistema",
        ),
        sa.Column(
            "settings",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Configurações específicas do papel",
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "context_type::text = ANY (ARRAY['system'::character varying::text, 'company'::character varying::text, 'establishment'::character varying::text])",
            name="roles_context_type_check",
        ),
        sa.PrimaryKeyConstraint("id", name="roles_pkey"),
        sa.UniqueConstraint(
            "name",
            name="roles_name_unique",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Papéis/funções do sistema RBAC",
        postgresql_ignore_search_path=False,
    )
    op.create_index(
        op.f("roles_settings_fulltext"),
        "roles",
        [sa.literal_column("to_tsvector('english'::regconfig, settings)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("roles_name_is_active_index"), "roles", ["name", "is_active"], unique=False
    )
    op.create_index(op.f("roles_level_index"), "roles", ["level"], unique=False)
    op.create_index(
        op.f("roles_is_system_role_index"), "roles", ["is_system_role"], unique=False
    )
    op.create_index(op.f("roles_is_active_index"), "roles", ["is_active"], unique=False)
    op.create_index(
        op.f("roles_context_type_index"), "roles", ["context_type"], unique=False
    )
    op.create_table(
        "alembic_version",
        sa.Column(
            "version_num", sa.VARCHAR(length=32), autoincrement=False, nullable=False
        ),
        sa.PrimaryKeyConstraint("version_num", name=op.f("alembic_version_pkc")),
    )
    op.create_table(
        "migrations",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "migration", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column("batch", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.PrimaryKeyConstraint("id", name=op.f("migrations_pkey")),
    )
    op.create_table(
        "user_establishments",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column("establishment_id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column("role_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column(
            "is_primary",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Se este é o estabelecimento principal do usuário",
        ),
        sa.Column(
            "status",
            sa.VARCHAR(length=20),
            server_default=sa.text("'active'::character varying"),
            autoincrement=False,
            nullable=True,
            comment="Status do relacionamento: active, inactive, suspended",
        ),
        sa.Column(
            "assigned_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "assigned_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "expires_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "permissions",
            postgresql.JSONB(astext_type=sa.Text()),
            server_default=sa.text("'{}'::jsonb"),
            autoincrement=False,
            nullable=True,
            comment="Permissões específicas do usuário neste estabelecimento",
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "deleted_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=True
        ),
        sa.ForeignKeyConstraint(
            ["assigned_by_user_id"],
            ["users.id"],
            name=op.f("user_establishments_assigned_by_user_id_fkey"),
        ),
        sa.ForeignKeyConstraint(
            ["establishment_id"],
            ["establishments.id"],
            name=op.f("user_establishments_establishment_id_fkey"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["role_id"], ["roles.id"], name=op.f("user_establishments_role_id_fkey")
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.id"],
            name=op.f("user_establishments_user_id_fkey"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("user_establishments_pkey")),
        sa.UniqueConstraint(
            "user_id",
            "establishment_id",
            name=op.f("user_establishments_user_id_establishment_id_key"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Relacionamento usuários com estabelecimentos - sistema multi-empresa",
    )
    op.create_index(
        op.f("idx_user_establishments_user_id"),
        "user_establishments",
        ["user_id"],
        unique=False,
        postgresql_where="(deleted_at IS NULL)",
    )
    op.create_index(
        op.f("idx_user_establishments_status"),
        "user_establishments",
        ["status"],
        unique=False,
        postgresql_where="(deleted_at IS NULL)",
    )
    op.create_index(
        op.f("idx_user_establishments_primary"),
        "user_establishments",
        ["user_id", "is_primary"],
        unique=False,
        postgresql_where="((is_primary = true) AND (deleted_at IS NULL))",
    )
    op.create_index(
        op.f("idx_user_establishments_establishment_id"),
        "user_establishments",
        ["establishment_id"],
        unique=False,
        postgresql_where="(deleted_at IS NULL)",
    )
    op.create_index(
        op.f("idx_user_establishments_deleted_at"),
        "user_establishments",
        ["deleted_at"],
        unique=False,
    )
    op.create_table(
        "clients",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "person_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment='Referência (FK) para o registro na tabela "people" que representa este cliente.',
        ),
        sa.Column(
            "establishment_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="Referência (FK) para o estabelecimento ao qual o cliente pertence.",
        ),
        sa.Column(
            "client_code",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=True,
            comment="Código único do cliente dentro do estabelecimento (opcional).",
        ),
        sa.Column(
            "status",
            sa.VARCHAR(length=255),
            server_default=sa.text("'active'::character varying"),
            autoincrement=False,
            nullable=False,
            comment="Status do cliente no estabelecimento: active, inactive, on_hold, archived.",
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "status::text = ANY (ARRAY['active'::character varying::text, 'inactive'::character varying::text, 'on_hold'::character varying::text, 'archived'::character varying::text])",
            name=op.f("clients_status_check"),
        ),
        sa.ForeignKeyConstraint(
            ["establishment_id"],
            ["establishments.id"],
            name=op.f("fk_clients_establishment"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["person_id"],
            ["people.id"],
            name=op.f("fk_clients_person"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("clients_pkey")),
        sa.UniqueConstraint(
            "establishment_id",
            "client_code",
            name=op.f("clients_establishment_id_client_code_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        sa.UniqueConstraint(
            "establishment_id",
            "person_id",
            name=op.f("clients_establishment_id_person_id_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment='Tabela de "Papel". Define o vínculo de uma entidade da tabela "people" como um cliente de um estabelecimento.',
    )
    op.create_index(op.f("clients_status_index"), "clients", ["status"], unique=False)
    op.create_index(
        op.f("clients_person_id_index"), "clients", ["person_id"], unique=False
    )
    op.create_index(
        op.f("clients_establishment_id_index"),
        "clients",
        ["establishment_id"],
        unique=False,
    )
    op.create_index(
        op.f("clients_deleted_at_index"), "clients", ["deleted_at"], unique=False
    )
    op.create_table(
        "activity_logs",
        sa.Column(
            "id",
            sa.BIGINT(),
            server_default=sa.text("nextval('activity_logs_id_seq'::regclass)"),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column(
            "log_name", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column(
            "subject_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="Tipo da entidade afetada pela ação (ex: App\\\\Models\\\\People).",
        ),
        sa.Column(
            "subject_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=True,
            comment="ID da entidade afetada pela ação.",
        ),
        sa.Column("event", sa.VARCHAR(length=255), autoincrement=False, nullable=True),
        sa.Column(
            "causer_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="Tipo da entidade que causou a ação (ex: App\\\\Models\\\\User).",
        ),
        sa.Column(
            "causer_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=True,
            comment="ID da entidade que causou a ação. Refere-se a master.users(id) se causer_type for de usuário.",
        ),
        sa.Column(
            "context_type",
            sa.VARCHAR(length=20),
            autoincrement=False,
            nullable=True,
            comment="Contexto onde a ação ocorreu (company, establishment).",
        ),
        sa.Column(
            "context_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=True,
            comment="ID do contexto onde a ação ocorreu.",
        ),
        sa.Column(
            "properties",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Propriedades adicionais da ação, como valores antigos e novos.",
        ),
        sa.Column("batch_uuid", sa.UUID(), autoincrement=False, nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "ip_address",
            sa.VARCHAR(length=45),
            autoincrement=False,
            nullable=True,
            comment="IP de origem da operação (obrigatório ANPD 2025)",
        ),
        sa.Column(
            "session_id",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="ID da sessão Laravel para rastreamento",
        ),
        sa.Column(
            "business_justification",
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
            comment="Justificativa de negócio da operação",
        ),
        sa.Column(
            "data_sensitivity_level",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="Nível de sensibilidade dos dados afetados",
        ),
        sa.Column(
            "processing_lawful_basis",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="Base legal para processamento (Art. 7º LGPD)",
        ),
        sa.Column(
            "user_agent",
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
            comment="User agent do navegador/sistema",
        ),
        sa.Column(
            "geographic_location",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=True,
            comment="Localização geográfica da operação",
        ),
        sa.CheckConstraint(
            "data_sensitivity_level::text = ANY (ARRAY['public'::character varying::text, 'internal'::character varying::text, 'confidential'::character varying::text, 'sensitive_personal'::character varying::text, 'highly_sensitive'::character varying::text])",
            name=op.f("activity_logs_data_sensitivity_level_check"),
        ),
        sa.CheckConstraint(
            "processing_lawful_basis::text = ANY (ARRAY['consent'::character varying::text, 'contract'::character varying::text, 'legal_obligation'::character varying::text, 'vital_interests'::character varying::text, 'public_task'::character varying::text, 'legitimate_interests'::character varying::text, 'credit_protection'::character varying::text, 'health_protection'::character varying::text, 'fraud_prevention'::character varying::text])",
            name=op.f("activity_logs_processing_lawful_basis_check"),
        ),
        sa.PrimaryKeyConstraint("id", "created_at", name=op.f("activity_logs_pkey")),
        comment="Log de auditoria de todas as ações do sistema com particionamento por data.",
    )
    op.create_index(
        op.f("idx_activity_logs_session"), "activity_logs", ["session_id"], unique=False
    )
    op.create_index(
        op.f("idx_activity_logs_sensitivity"),
        "activity_logs",
        ["data_sensitivity_level"],
        unique=False,
    )
    op.create_index(
        op.f("idx_activity_logs_ip"), "activity_logs", ["ip_address"], unique=False
    )
    op.create_index(
        op.f("idx_activity_logs_basis"),
        "activity_logs",
        ["processing_lawful_basis"],
        unique=False,
    )
    op.create_index(
        op.f("idx_activity_logs_audit"),
        "activity_logs",
        ["created_at", "ip_address"],
        unique=False,
    )
    op.create_index(
        op.f("activity_logs_subject_type_subject_id_index"),
        "activity_logs",
        ["subject_type", "subject_id"],
        unique=False,
    )
    op.create_index(
        op.f("activity_logs_log_name_index"),
        "activity_logs",
        ["log_name"],
        unique=False,
    )
    op.create_index(
        op.f("activity_logs_created_at_index"),
        "activity_logs",
        ["created_at"],
        unique=False,
    )
    op.create_index(
        op.f("activity_logs_causer_type_causer_id_index"),
        "activity_logs",
        ["causer_type", "causer_id"],
        unique=False,
    )
    op.create_table(
        "password_reset_tokens",
        sa.Column("email", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("token", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("email", name=op.f("password_reset_tokens_pkey")),
        comment="Tokens para reset de senha do sistema de autenticação Laravel.",
    )
    op.create_table(
        "user_roles",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "user_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID da conta de acesso que recebe o papel.",
        ),
        sa.Column(
            "role_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID do papel atribuído.",
        ),
        sa.Column(
            "context_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Tipo de contexto: system, company, establishment.",
        ),
        sa.Column(
            "context_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID da entidade de contexto (ex: company_id ou establishment_id).",
        ),
        sa.Column(
            "status",
            sa.VARCHAR(length=255),
            server_default=sa.text("'active'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "assigned_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "assigned_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "expires_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "context_type::text = ANY (ARRAY['system'::character varying::text, 'company'::character varying::text, 'establishment'::character varying::text])",
            name=op.f("user_roles_context_type_check"),
        ),
        sa.CheckConstraint(
            "status::text = ANY (ARRAY['active'::character varying::text, 'inactive'::character varying::text, 'suspended'::character varying::text, 'expired'::character varying::text])",
            name=op.f("user_roles_status_check"),
        ),
        sa.ForeignKeyConstraint(
            ["assigned_by_user_id"],
            ["users.id"],
            name=op.f("fk_user_roles_assigned_by"),
            ondelete="SET NULL",
        ),
        sa.ForeignKeyConstraint(
            ["role_id"],
            ["roles.id"],
            name=op.f("fk_user_roles_role"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.id"],
            name=op.f("fk_user_roles_user"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("user_roles_pkey")),
        sa.UniqueConstraint(
            "user_id",
            "role_id",
            "context_type",
            "context_id",
            name=op.f("user_roles_user_id_role_id_context_type_context_id_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Relacionamento N:M entre contas de acesso (users) e papéis (roles) com contexto específico.",
    )
    op.create_index(
        op.f("user_roles_user_id_index"), "user_roles", ["user_id"], unique=False
    )
    op.create_index(
        op.f("user_roles_user_id_context_type_context_id_index"),
        "user_roles",
        ["user_id", "context_type", "context_id"],
        unique=False,
    )
    op.create_index(
        op.f("user_roles_role_id_index"), "user_roles", ["role_id"], unique=False
    )
    op.create_index(
        op.f("user_roles_deleted_at_index"), "user_roles", ["deleted_at"], unique=False
    )
    op.create_index(
        op.f("user_roles_context_type_context_id_index"),
        "user_roles",
        ["context_type", "context_id"],
        unique=False,
    )
    op.create_table(
        "establishment_settings",
        sa.Column("id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column(
            "establishment_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID do estabelecimento proprietário da configuração.",
        ),
        sa.Column(
            "setting_key",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=False,
            comment="Chave única da configuração (ex: scheduling.slot_duration).",
        ),
        sa.Column(
            "setting_category",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "setting_name", sa.VARCHAR(length=200), autoincrement=False, nullable=False
        ),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "setting_value",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Valor atual da configuração em formato JSONB. Se nulo, herda da empresa.",
        ),
        sa.Column(
            "default_value",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "data_type",
            sa.VARCHAR(length=20),
            server_default=sa.text("'string'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "is_required",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_editable",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "input_type",
            sa.VARCHAR(length=30),
            server_default=sa.text("'text'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.ForeignKeyConstraint(
            ["establishment_id"],
            ["establishments.id"],
            name=op.f("fk_establishment_settings_establishment"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["updated_by_user_id"],
            ["users.id"],
            name=op.f("fk_establishment_settings_updated_by"),
            ondelete="SET NULL",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("establishment_settings_pkey")),
        sa.UniqueConstraint(
            "establishment_id",
            "setting_key",
            name=op.f("establishment_settings_establishment_id_setting_key_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Configurações específicas por estabelecimento (modelo EAV), com herança da empresa.",
    )
    op.create_index(
        op.f("establishment_settings_setting_value_fulltext"),
        "establishment_settings",
        [sa.literal_column("to_tsvector('english'::regconfig, setting_value)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("establishment_settings_setting_key_index"),
        "establishment_settings",
        ["setting_key"],
        unique=False,
    )
    op.create_index(
        op.f("establishment_settings_setting_category_index"),
        "establishment_settings",
        ["setting_category"],
        unique=False,
    )
    op.create_index(
        op.f("establishment_settings_establishment_id_index"),
        "establishment_settings",
        ["establishment_id"],
        unique=False,
    )
    op.create_table(
        "sessions",
        sa.Column("id", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("user_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column("ip_address", postgresql.INET(), autoincrement=False, nullable=True),
        sa.Column("user_agent", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column("payload", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("last_activity", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.PrimaryKeyConstraint("id", name=op.f("sessions_pkey")),
    )
    op.create_index(
        op.f("sessions_user_id_index"), "sessions", ["user_id"], unique=False
    )
    op.create_index(
        op.f("sessions_last_activity_index"),
        "sessions",
        ["last_activity"],
        unique=False,
    )
    op.create_table(
        "professionals",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "pf_person_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment='Referência (FK) obrigatória para a identidade da Pessoa Física na tabela "people".',
        ),
        sa.Column(
            "pj_person_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=True,
            comment='Referência (FK) opcional para a identidade da Pessoa Jurídica (MEI) na tabela "people".',
        ),
        sa.Column(
            "establishment_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="Referência (FK) para o estabelecimento ao qual o profissional está vinculado.",
        ),
        sa.Column(
            "professional_code",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "status",
            sa.VARCHAR(length=255),
            server_default=sa.text("'active'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "specialties",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Lista de especialidades do profissional em formato JSONB.",
        ),
        sa.Column("admission_date", sa.DATE(), autoincrement=False, nullable=True),
        sa.Column("termination_date", sa.DATE(), autoincrement=False, nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "status::text = ANY (ARRAY['active'::character varying::text, 'inactive'::character varying::text, 'on_leave'::character varying::text, 'suspended'::character varying::text])",
            name=op.f("professionals_status_check"),
        ),
        sa.ForeignKeyConstraint(
            ["establishment_id"],
            ["establishments.id"],
            name=op.f("fk_professionals_establishment"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["pf_person_id"],
            ["people.id"],
            name=op.f("fk_professionals_person_pf"),
            ondelete="RESTRICT",
        ),
        sa.ForeignKeyConstraint(
            ["pj_person_id"],
            ["people.id"],
            name=op.f("fk_professionals_person_pj"),
            ondelete="SET NULL",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("professionals_pkey")),
        sa.UniqueConstraint(
            "establishment_id",
            "professional_code",
            name=op.f("professionals_establishment_id_professional_code_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        sa.UniqueConstraint(
            "pf_person_id",
            name=op.f("professionals_pf_person_id_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        sa.UniqueConstraint(
            "pj_person_id",
            name=op.f("professionals_pj_person_id_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment='Tabela de "Papel". Define os profissionais de home care, ligando suas identidades PF e PJ (MEI).',
    )
    op.create_index(
        op.f("professionals_status_index"), "professionals", ["status"], unique=False
    )
    op.create_index(
        op.f("professionals_specialties_fulltext"),
        "professionals",
        [sa.literal_column("to_tsvector('english'::regconfig, specialties)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("professionals_pj_person_id_index"),
        "professionals",
        ["pj_person_id"],
        unique=False,
    )
    op.create_index(
        op.f("professionals_pf_person_id_index"),
        "professionals",
        ["pf_person_id"],
        unique=False,
    )
    op.create_index(
        op.f("professionals_establishment_id_index"),
        "professionals",
        ["establishment_id"],
        unique=False,
    )
    op.create_index(
        op.f("professionals_deleted_at_index"),
        "professionals",
        ["deleted_at"],
        unique=False,
    )
    op.create_table(
        "lgpd_incidents",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "incident_id",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=False,
            comment="ID único do incidente",
        ),
        sa.Column(
            "occurred_at",
            postgresql.TIMESTAMP(timezone=True, precision=0),
            autoincrement=False,
            nullable=False,
            comment="Data/hora do incidente",
        ),
        sa.Column(
            "detected_at",
            postgresql.TIMESTAMP(timezone=True, precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "incident_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Tipo de incidente",
        ),
        sa.Column(
            "severity",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Severidade do incidente",
        ),
        sa.Column(
            "affected_subjects_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "affected_data_categories",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=False,
            comment="Categorias de dados afetados",
        ),
        sa.Column(
            "involves_sensitive_data",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "description",
            sa.TEXT(),
            autoincrement=False,
            nullable=False,
            comment="Descrição do incidente",
        ),
        sa.Column("root_cause", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column("mitigation_actions", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "anpd_notified",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "anpd_notification_at",
            postgresql.TIMESTAMP(timezone=True, precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "subjects_notified",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "status",
            sa.VARCHAR(length=255),
            server_default=sa.text("'open'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "responsible_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "incident_type::text = ANY (ARRAY['data_breach'::character varying::text, 'unauthorized_access'::character varying::text, 'data_loss'::character varying::text, 'system_compromise'::character varying::text, 'privacy_violation'::character varying::text, 'consent_violation'::character varying::text])",
            name=op.f("lgpd_incidents_incident_type_check"),
        ),
        sa.CheckConstraint(
            "severity::text = ANY (ARRAY['low'::character varying::text, 'medium'::character varying::text, 'high'::character varying::text, 'critical'::character varying::text])",
            name=op.f("lgpd_incidents_severity_check"),
        ),
        sa.CheckConstraint(
            "status::text = ANY (ARRAY['open'::character varying::text, 'investigating'::character varying::text, 'resolved'::character varying::text, 'closed'::character varying::text])",
            name=op.f("lgpd_incidents_status_check"),
        ),
        sa.ForeignKeyConstraint(
            ["responsible_user_id"],
            ["users.id"],
            name=op.f("fk_incidents_user"),
            ondelete="SET NULL",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("lgpd_incidents_pkey")),
        sa.UniqueConstraint(
            "incident_id",
            name=op.f("master_lgpd_incidents_incident_id_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Registro de incidentes de segurança/privacidade - ANPD Resolution 15/2024",
    )
    op.create_index(
        op.f("idx_incidents_type_severity"),
        "lgpd_incidents",
        ["incident_type", "severity"],
        unique=False,
    )
    op.create_index(
        op.f("idx_incidents_status"), "lgpd_incidents", ["status"], unique=False
    )
    op.create_index(
        op.f("idx_incidents_occurred"), "lgpd_incidents", ["occurred_at"], unique=False
    )
    op.create_table(
        "user_contexts",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column(
            "session_id", sa.VARCHAR(length=40), autoincrement=False, nullable=True
        ),
        sa.Column(
            "context_type", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column("context_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column(
            "previous_context_type",
            sa.VARCHAR(length=20),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "previous_context_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "change_reason", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "switched_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "ip_address", sa.VARCHAR(length=45), autoincrement=False, nullable=True
        ),
        sa.Column("user_agent", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "ended_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("duration_seconds", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "change_reason::text = ANY (ARRAY['login'::character varying::text, 'switch'::character varying::text, 'impersonation_start'::character varying::text, 'impersonation_end'::character varying::text, 'forced_switch'::character varying::text, 'session_timeout'::character varying::text, 'logout'::character varying::text, 'auto_switch'::character varying::text])",
            name=op.f("user_contexts_change_reason_check"),
        ),
        sa.CheckConstraint(
            "context_type::text = ANY (ARRAY['system'::character varying::text, 'company'::character varying::text, 'establishment'::character varying::text])",
            name=op.f("user_contexts_context_type_check"),
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.id"],
            name=op.f("fk_user_contexts_user"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("user_contexts_pkey")),
        comment="Histórico e controle de mudanças de contexto das contas de acesso.",
    )
    op.create_index(
        op.f("user_contexts_user_id_session_id_index"),
        "user_contexts",
        ["user_id", "session_id"],
        unique=False,
    )
    op.create_index(
        op.f("user_contexts_user_id_index"), "user_contexts", ["user_id"], unique=False
    )
    op.create_index(
        op.f("user_contexts_switched_at_index"),
        "user_contexts",
        ["switched_at"],
        unique=False,
    )
    op.create_index(
        op.f("user_contexts_session_id_index"),
        "user_contexts",
        ["session_id"],
        unique=False,
    )
    op.create_index(
        op.f("user_contexts_context_type_context_id_index"),
        "user_contexts",
        ["context_type", "context_id"],
        unique=False,
    )
    op.create_table(
        "phones",
        sa.Column(
            "id",
            sa.BIGINT(),
            server_default=sa.text("nextval('phones_id_seq'::regclass)"),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column(
            "phoneable_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Classe do modelo proprietário do telefone.",
        ),
        sa.Column(
            "phoneable_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID do registro proprietário do telefone.",
        ),
        sa.Column(
            "type",
            sa.VARCHAR(length=255),
            server_default=sa.text("'mobile'::character varying"),
            autoincrement=False,
            nullable=False,
            comment="Tipo: landline, mobile, whatsapp, commercial, emergency, fax.",
        ),
        sa.Column(
            "country_code",
            sa.VARCHAR(length=3),
            server_default=sa.text("'55'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "number",
            sa.VARCHAR(length=11),
            autoincrement=False,
            nullable=False,
            comment="Número limpo (só dígitos): DDD + número (10-11 dígitos).",
        ),
        sa.Column(
            "extension", sa.VARCHAR(length=10), autoincrement=False, nullable=True
        ),
        sa.Column(
            "is_whatsapp",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Se o número tem WhatsApp ativo.",
        ),
        sa.Column(
            "whatsapp_formatted",
            sa.VARCHAR(length=15),
            autoincrement=False,
            nullable=True,
            comment="Número formatado para links WhatsApp (+5511999999999).",
        ),
        sa.Column(
            "whatsapp_verified",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Se foi verificado via WhatsApp Business API.",
        ),
        sa.Column(
            "whatsapp_verified_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "whatsapp_business",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Se é conta WhatsApp Business verificada.",
        ),
        sa.Column(
            "whatsapp_name",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=True,
            comment="Nome exibido no WhatsApp Business.",
        ),
        sa.Column(
            "accepts_whatsapp_marketing",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Aceita receber mensagens de marketing via WhatsApp.",
        ),
        sa.Column(
            "accepts_whatsapp_notifications",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
            comment="Aceita notificações de sistema via WhatsApp.",
        ),
        sa.Column(
            "whatsapp_preferred_time_start",
            postgresql.TIME(precision=0),
            server_default=sa.text("'08:00:00'::time without time zone"),
            autoincrement=False,
            nullable=True,
            comment="Horário preferido INÍCIO para receber mensagens.",
        ),
        sa.Column(
            "whatsapp_preferred_time_end",
            postgresql.TIME(precision=0),
            server_default=sa.text("'18:00:00'::time without time zone"),
            autoincrement=False,
            nullable=True,
            comment="Horário preferido FIM para receber mensagens.",
        ),
        sa.Column(
            "phone_name",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=True,
            comment="Apelido do telefone (Pessoal, Trabalho, etc.).",
        ),
        sa.Column(
            "carrier",
            sa.VARCHAR(length=30),
            autoincrement=False,
            nullable=True,
            comment="Operadora: Vivo, Claro, Tim, Oi, etc.",
        ),
        sa.Column(
            "line_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="Tipo de linha: prepaid, postpaid, corporate.",
        ),
        sa.Column(
            "is_principal",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "can_receive_calls",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "can_receive_sms",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "contact_priority",
            sa.INTEGER(),
            server_default=sa.text("1"),
            autoincrement=False,
            nullable=True,
            comment="Prioridade de contato (1=maior, 10=menor).",
        ),
        sa.Column(
            "verified_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
            comment="Quando o número foi verificado pela última vez.",
        ),
        sa.Column(
            "verification_method",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="Método de verificação: call, sms, whatsapp, manual, api.",
        ),
        sa.Column(
            "last_contact_attempt",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "last_contact_success",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "contact_attempts_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "api_data",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Dados completos das APIs de telefone/WhatsApp em JSONB.",
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "updated_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.CheckConstraint(
            "line_type::text = ANY (ARRAY['prepaid'::character varying::text, 'postpaid'::character varying::text, 'corporate'::character varying::text])",
            name=op.f("phones_line_type_check"),
        ),
        sa.CheckConstraint(
            "type::text = ANY (ARRAY['landline'::character varying::text, 'mobile'::character varying::text, 'whatsapp'::character varying::text, 'commercial'::character varying::text, 'emergency'::character varying::text, 'fax'::character varying::text])",
            name=op.f("phones_type_check"),
        ),
        sa.CheckConstraint(
            "verification_method::text = ANY (ARRAY['call'::character varying::text, 'sms'::character varying::text, 'whatsapp'::character varying::text, 'manual'::character varying::text, 'api'::character varying::text])",
            name=op.f("phones_verification_method_check"),
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("phones_pkey")),
        comment="Telefones polimórficos com integração completa ao WhatsApp e APIs de validação.",
    )
    op.create_index(
        op.f("phones_whatsapp_verified_whatsapp_verified_at_index"),
        "phones",
        ["whatsapp_verified", "whatsapp_verified_at"],
        unique=False,
    )
    op.create_index(
        op.f("phones_whatsapp_formatted_index"),
        "phones",
        ["whatsapp_formatted"],
        unique=False,
    )
    op.create_index(
        op.f("phones_whatsapp_business_index"),
        "phones",
        ["whatsapp_business"],
        unique=False,
    )
    op.create_index(
        op.f("phones_verified_at_index"), "phones", ["verified_at"], unique=False
    )
    op.create_index(
        op.f("phones_phoneable_type_phoneable_id_whatsapp_formatted_index"),
        "phones",
        ["phoneable_type", "phoneable_id", "whatsapp_formatted"],
        unique=False,
    )
    op.create_index(
        op.f("phones_phoneable_type_phoneable_id_index"),
        "phones",
        ["phoneable_type", "phoneable_id"],
        unique=False,
    )
    op.create_index(op.f("phones_number_index"), "phones", ["number"], unique=False)
    op.create_index(
        op.f("phones_is_whatsapp_index"), "phones", ["is_whatsapp"], unique=False
    )
    op.create_index(
        op.f("phones_deleted_at_index"), "phones", ["deleted_at"], unique=False
    )
    op.create_index(op.f("phones_carrier_index"), "phones", ["carrier"], unique=False)
    op.create_index(
        op.f("phones_api_data_fulltext"),
        "phones",
        [sa.literal_column("to_tsvector('english'::regconfig, api_data)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("phones_accepts_whatsapp_marketing_index"),
        "phones",
        ["accepts_whatsapp_marketing"],
        unique=False,
    )
    op.create_table(
        "cache",
        sa.Column("key", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("value", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("expiration", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.PrimaryKeyConstraint("key", name=op.f("cache_pkey")),
    )
    op.create_table(
        "companies",
        sa.Column(
            "id",
            sa.BIGINT(),
            server_default=sa.text("nextval('companies_id_seq'::regclass)"),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column(
            "person_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment='Referência (FK) para o registro correspondente na tabela "people" (deve ser do tipo "PJ").',
        ),
        sa.Column(
            "settings",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Configurações específicas da empresa DENTRO do sistema Pro Team Care.",
        ),
        sa.Column(
            "metadata",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Dados adicionais flexíveis sobre o status da empresa como cliente.",
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "display_order",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.ForeignKeyConstraint(
            ["person_id"], ["people.id"], name="fk_companies_person", ondelete="CASCADE"
        ),
        sa.PrimaryKeyConstraint("id", name="companies_pkey"),
        sa.UniqueConstraint(
            "person_id",
            name="companies_person_id_unique",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment='Tabela de "Papel". Define quais registros da tabela "people" são empresas clientes do sistema Pro Team Care.',
        postgresql_ignore_search_path=False,
    )
    op.create_index(
        op.f("companies_settings_fulltext"),
        "companies",
        [sa.literal_column("to_tsvector('english'::regconfig, settings)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("companies_person_id_index"), "companies", ["person_id"], unique=False
    )
    op.create_index(
        op.f("companies_metadata_fulltext"),
        "companies",
        [sa.literal_column("to_tsvector('english'::regconfig, metadata)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("companies_deleted_at_index"), "companies", ["deleted_at"], unique=False
    )
    op.create_table(
        "lgpd_audit_config",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "table_name", sa.VARCHAR(length=63), autoincrement=False, nullable=False
        ),
        sa.Column(
            "operation", sa.VARCHAR(length=20), autoincrement=False, nullable=False
        ),
        sa.Column(
            "audit_enabled",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "requires_justification",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "data_sensitivity_level",
            sa.VARCHAR(length=255),
            server_default=sa.text("'internal'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "sensitive_columns",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Colunas consideradas sensíveis",
        ),
        sa.Column(
            "retention_days",
            sa.INTEGER(),
            server_default=sa.text("2555"),
            autoincrement=False,
            nullable=False,
            comment="Dias de retenção dos logs (7 anos padrão)",
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "data_sensitivity_level::text = ANY (ARRAY['public'::character varying::text, 'internal'::character varying::text, 'confidential'::character varying::text, 'sensitive_personal'::character varying::text, 'highly_sensitive'::character varying::text])",
            name=op.f("lgpd_audit_config_data_sensitivity_level_check"),
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("lgpd_audit_config_pkey")),
        sa.UniqueConstraint(
            "table_name",
            "operation",
            name=op.f("uk_audit_config"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Configurações de auditoria LGPD por tabela/operação",
    )
    op.create_index(
        op.f("master_lgpd_audit_config_table_name_index"),
        "lgpd_audit_config",
        ["table_name"],
        unique=False,
    )
    op.create_table(
        "menus",
        sa.Column("id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column(
            "parent_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=True,
            comment="ID do menu pai (NULL para menus raiz).",
        ),
        sa.Column(
            "level",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
            comment="Nível na hierarquia (0=raiz, calculado automaticamente).",
        ),
        sa.Column(
            "sort_order",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "name",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=False,
            comment="Nome exibido no menu.",
        ),
        sa.Column(
            "slug",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=False,
            comment="Identificador único URL-friendly.",
        ),
        sa.Column(
            "path",
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
            comment="Caminho completo na hierarquia (ex: cadastros/pessoas/clientes).",
        ),
        sa.Column(
            "url",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="URL absoluta ou relativa do menu.",
        ),
        sa.Column(
            "route_name",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=True,
            comment="Nome da rota Laravel.",
        ),
        sa.Column(
            "route_params",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Parâmetros da rota em formato JSONB.",
        ),
        sa.Column(
            "icon",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=True,
            comment="Classe CSS do ícone (FontAwesome, Bootstrap Icons, etc).",
        ),
        sa.Column("color", sa.VARCHAR(length=20), autoincrement=False, nullable=True),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "permission_name",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="Permissão necessária (integração com Spatie Permission).",
        ),
        sa.Column(
            "required_permissions",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Múltiplas permissões com operador AND/OR.",
        ),
        sa.Column(
            "required_roles",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Roles necessárias com operador AND/OR.",
        ),
        sa.Column(
            "target",
            sa.VARCHAR(length=255),
            server_default=sa.text("'_self'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "type",
            sa.VARCHAR(length=255),
            server_default=sa.text("'menu'::character varying"),
            autoincrement=False,
            nullable=True,
            comment="Tipo: menu, divider, header, separator.",
        ),
        sa.Column(
            "accepts_children",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "badge_text",
            sa.VARCHAR(length=20),
            autoincrement=False,
            nullable=True,
            comment="Texto do badge/contador no menu.",
        ),
        sa.Column(
            "badge_color", sa.VARCHAR(length=20), autoincrement=False, nullable=True
        ),
        sa.Column("badge_expression", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "visible_in_menu",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "visible_in_breadcrumb",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_featured",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "company_specific",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Se é específico para certas empresas.",
        ),
        sa.Column(
            "allowed_companies",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "establishment_specific",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Se é específico para estabelecimentos.",
        ),
        sa.Column(
            "allowed_establishments",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "metadata",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_visible",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "dev_only",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "updated_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.CheckConstraint(
            "target::text = ANY (ARRAY['_self'::character varying::text, '_blank'::character varying::text, '_parent'::character varying::text, '_top'::character varying::text])",
            name=op.f("menus_target_check"),
        ),
        sa.CheckConstraint(
            "type::text = ANY (ARRAY['menu'::character varying::text, 'divider'::character varying::text, 'header'::character varying::text, 'separator'::character varying::text])",
            name=op.f("menus_type_check"),
        ),
        sa.ForeignKeyConstraint(
            ["parent_id"],
            ["menus.id"],
            name=op.f("fk_menus_parent"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("menus_pkey")),
        sa.UniqueConstraint(
            "slug",
            name=op.f("menus_slug_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Sistema de menus hierárquicos integrado com RBAC do Spatie Laravel Permission.",
    )
    op.create_index(
        op.f("menus_visible_in_menu_index"), "menus", ["visible_in_menu"], unique=False
    )
    op.create_index(
        op.f("menus_sort_order_index"), "menus", ["sort_order"], unique=False
    )
    op.create_index(
        op.f("menus_route_name_index"), "menus", ["route_name"], unique=False
    )
    op.create_index(
        op.f("menus_required_roles_fulltext"),
        "menus",
        [sa.literal_column("to_tsvector('english'::regconfig, required_roles)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("menus_required_permissions_fulltext"),
        "menus",
        [sa.literal_column("to_tsvector('english'::regconfig, required_permissions)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("menus_permission_name_index"), "menus", ["permission_name"], unique=False
    )
    op.create_index(op.f("menus_path_index"), "menus", ["path"], unique=False)
    op.create_index(
        op.f("menus_parent_id_sort_order_index"),
        "menus",
        ["parent_id", "sort_order"],
        unique=False,
    )
    op.create_index(op.f("menus_parent_id_index"), "menus", ["parent_id"], unique=False)
    op.create_index(
        op.f("menus_level_sort_order_index"),
        "menus",
        ["level", "sort_order"],
        unique=False,
    )
    op.create_index(op.f("menus_level_index"), "menus", ["level"], unique=False)
    op.create_index(
        op.f("menus_is_active_is_visible_index"),
        "menus",
        ["is_active", "is_visible"],
        unique=False,
    )
    op.create_index(op.f("menus_dev_only_index"), "menus", ["dev_only"], unique=False)
    op.create_index(
        op.f("menus_deleted_at_index"), "menus", ["deleted_at"], unique=False
    )
    op.create_index(
        op.f("menus_allowed_establishments_fulltext"),
        "menus",
        [
            sa.literal_column(
                "to_tsvector('english'::regconfig, allowed_establishments)"
            )
        ],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("menus_allowed_companies_fulltext"),
        "menus",
        [sa.literal_column("to_tsvector('english'::regconfig, allowed_companies)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_table(
        "data_privacy_logs",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "operation_type", sa.VARCHAR(length=50), autoincrement=False, nullable=False
        ),
        sa.Column(
            "data_category", sa.VARCHAR(length=50), autoincrement=False, nullable=False
        ),
        sa.Column("person_id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column("operator_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column(
            "context_type", sa.VARCHAR(length=20), autoincrement=False, nullable=True
        ),
        sa.Column("context_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column(
            "purpose", sa.VARCHAR(length=200), autoincrement=False, nullable=False
        ),
        sa.Column(
            "legal_basis", sa.VARCHAR(length=50), autoincrement=False, nullable=False
        ),
        sa.Column(
            "data_fields",
            postgresql.JSON(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_sensitive_data",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column("consent_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column("compliance_notes", sa.TEXT(), autoincrement=False, nullable=True),
        sa.PrimaryKeyConstraint("id", name=op.f("data_privacy_logs_pkey")),
    )
    op.create_index(
        op.f("data_privacy_logs_person_id_index"),
        "data_privacy_logs",
        ["person_id"],
        unique=False,
    )
    op.create_index(
        op.f("data_privacy_logs_operator_id_index"),
        "data_privacy_logs",
        ["operator_id"],
        unique=False,
    )
    op.create_index(
        op.f("data_privacy_logs_operation_type_index"),
        "data_privacy_logs",
        ["operation_type"],
        unique=False,
    )
    op.create_index(
        op.f("data_privacy_logs_is_sensitive_data_created_at_index"),
        "data_privacy_logs",
        ["is_sensitive_data", "created_at"],
        unique=False,
    )
    op.create_index(
        op.f("data_privacy_logs_created_at_index"),
        "data_privacy_logs",
        ["created_at"],
        unique=False,
    )
    op.create_table(
        "failed_jobs",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column("uuid", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("connection", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("queue", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("payload", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("exception", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column(
            "failed_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=False,
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("failed_jobs_pkey")),
        sa.UniqueConstraint(
            "uuid",
            name=op.f("master_failed_jobs_uuid_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Jobs que falharam durante execução.",
    )
    op.create_table(
        "job_batches",
        sa.Column("id", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("name", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("total_jobs", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("pending_jobs", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("failed_jobs", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("failed_job_ids", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("options", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column("cancelled_at", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column("created_at", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("finished_at", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.PrimaryKeyConstraint("id", name=op.f("job_batches_pkey")),
        comment="Lotes de jobs agrupados do Laravel.",
    )
    op.create_table(
        "emails",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "emailable_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="O nome da classe do modelo proprietário do email (ex: App\\\\Models\\\\Company).",
        ),
        sa.Column(
            "emailable_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="O ID do registro proprietário do email.",
        ),
        sa.Column(
            "type",
            sa.VARCHAR(length=255),
            server_default=sa.text("'work'::character varying"),
            autoincrement=False,
            nullable=False,
            comment="Tipo: personal, work (trabalho), billing (faturamento), contact (contato).",
        ),
        sa.Column(
            "email_address",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="O endereço de email.",
        ),
        sa.Column(
            "is_principal",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Indica se é o email principal da entidade.",
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "verified_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "type::text = ANY (ARRAY['personal'::character varying::text, 'work'::character varying::text, 'billing'::character varying::text, 'contact'::character varying::text])",
            name=op.f("emails_type_check"),
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("emails_pkey")),
        comment="Emails polimórficos para as entidades do sistema.",
    )
    op.create_index(
        op.f("emails_emailable_type_emailable_id_index"),
        "emails",
        ["emailable_type", "emailable_id"],
        unique=False,
    )
    op.create_index(
        op.f("emails_email_address_index"), "emails", ["email_address"], unique=False
    )
    op.create_index(
        op.f("emails_deleted_at_index"), "emails", ["deleted_at"], unique=False
    )
    op.create_table(
        "addresses",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "addressable_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Tipo da entidade (App\\Models\\Person, App\\Models\\Company, etc.)",
        ),
        sa.Column(
            "addressable_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID da entidade que possui este endereço",
        ),
        sa.Column(
            "type",
            sa.VARCHAR(length=255),
            server_default=sa.text("'residential'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "street",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Logradouro (rua, avenida, etc.)",
        ),
        sa.Column(
            "number",
            sa.VARCHAR(length=20),
            autoincrement=False,
            nullable=True,
            comment="Número do imóvel",
        ),
        sa.Column(
            "details",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
            comment="Complemento (apartamento, bloco, etc.)",
        ),
        sa.Column(
            "neighborhood",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Bairro",
        ),
        sa.Column(
            "city",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Cidade",
        ),
        sa.Column(
            "state",
            sa.VARCHAR(length=2),
            autoincrement=False,
            nullable=False,
            comment="Estado (sigla UF)",
        ),
        sa.Column(
            "zip_code",
            sa.VARCHAR(length=10),
            autoincrement=False,
            nullable=False,
            comment="CEP",
        ),
        sa.Column(
            "country",
            sa.VARCHAR(length=2),
            server_default=sa.text("'BR'::character varying"),
            autoincrement=False,
            nullable=False,
            comment="País (código ISO)",
        ),
        sa.Column(
            "latitude",
            sa.NUMERIC(precision=10, scale=8),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "longitude",
            sa.NUMERIC(precision=11, scale=8),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "geocoding_accuracy",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "geocoding_source",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "google_place_id",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("formatted_address", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column("ibge_city_code", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column("ibge_state_code", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column("region", sa.VARCHAR(length=255), autoincrement=False, nullable=True),
        sa.Column(
            "microregion", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "mesoregion", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "area_code", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "gia_code", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "siafi_code", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "quality_score",
            sa.INTEGER(),
            autoincrement=False,
            nullable=True,
            comment="Score de qualidade do endereço (0-100)",
        ),
        sa.Column(
            "is_validated",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "last_validated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "validation_source",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "api_data",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Dados brutos das APIs de geolocalização",
        ),
        sa.Column("within_coverage", sa.BOOLEAN(), autoincrement=False, nullable=True),
        sa.Column(
            "distance_to_establishment",
            sa.INTEGER(),
            autoincrement=False,
            nullable=True,
            comment="Distância em metros",
        ),
        sa.Column(
            "estimated_travel_time",
            sa.INTEGER(),
            autoincrement=False,
            nullable=True,
            comment="Tempo estimado em minutos",
        ),
        sa.Column(
            "access_difficulty",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("access_notes", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "is_principal",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_confirmed",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "confirmed_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "confirmed_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "updated_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.CheckConstraint(
            "access_difficulty::text = ANY (ARRAY['easy'::character varying::text, 'medium'::character varying::text, 'hard'::character varying::text, 'unknown'::character varying::text])",
            name=op.f("addresses_access_difficulty_check"),
        ),
        sa.CheckConstraint(
            "type::text = ANY (ARRAY['residential'::character varying::text, 'commercial'::character varying::text, 'correspondence'::character varying::text, 'billing'::character varying::text, 'delivery'::character varying::text, 'other'::character varying::text])",
            name=op.f("addresses_type_check"),
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("addresses_pkey")),
        comment="Tabela polimórfica para endereços de pessoas, empresas e estabelecimentos. Suporta múltiplos endereços por entidade.",
    )
    op.create_index(
        op.f("master_addresses_deleted_at_index"),
        "addresses",
        ["deleted_at"],
        unique=False,
    )
    op.create_index(
        op.f("idx_addresses_zip_code"), "addresses", ["zip_code"], unique=False
    )
    op.create_index(
        op.f("idx_addresses_validated"), "addresses", ["is_validated"], unique=False
    )
    op.create_index(op.f("idx_addresses_region"), "addresses", ["region"], unique=False)
    op.create_index(
        op.f("idx_addresses_quality_score"),
        "addresses",
        ["quality_score"],
        unique=False,
    )
    op.create_index(
        op.f("idx_addresses_principal"), "addresses", ["is_principal"], unique=False
    )
    op.create_index(
        op.f("idx_addresses_polymorphic"),
        "addresses",
        ["addressable_type", "addressable_id"],
        unique=False,
    )
    op.create_index(
        op.f("idx_addresses_ibge_codes"),
        "addresses",
        ["ibge_city_code", "ibge_state_code"],
        unique=False,
    )
    op.create_index(
        op.f("idx_addresses_google_place_id"),
        "addresses",
        ["google_place_id"],
        unique=False,
    )
    op.create_index(
        op.f("idx_addresses_distance"),
        "addresses",
        ["distance_to_establishment"],
        unique=False,
    )
    op.create_index(
        op.f("idx_addresses_deleted_at"), "addresses", ["deleted_at"], unique=False
    )
    op.create_index(
        op.f("idx_addresses_coverage"), "addresses", ["within_coverage"], unique=False
    )
    op.create_index(
        op.f("idx_addresses_coordinates"),
        "addresses",
        ["latitude", "longitude"],
        unique=False,
        postgresql_where="((latitude IS NOT NULL) AND (longitude IS NOT NULL))",
    )
    op.create_index(
        op.f("idx_addresses_city_state"), "addresses", ["city", "state"], unique=False
    )
    op.create_index(
        op.f("idx_addresses_area_code"), "addresses", ["area_code"], unique=False
    )
    op.create_index(
        op.f("idx_addresses_api_data_gin"),
        "addresses",
        ["api_data"],
        unique=False,
        postgresql_using="gin",
    )
    op.create_table(
        "migrations",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "migration", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column("batch", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.PrimaryKeyConstraint("id", name=op.f("migrations_pkey")),
        schema="public",
    )
    op.create_table(
        "consent_records",
        sa.Column("id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column(
            "person_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment='ID do titular dos dados na tabela "people".',
        ),
        sa.Column(
            "consent_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Tipo de consentimento: data_processing, marketing, etc.",
        ),
        sa.Column(
            "purpose",
            sa.VARCHAR(length=500),
            autoincrement=False,
            nullable=False,
            comment="Finalidade específica do consentimento.",
        ),
        sa.Column(
            "data_categories",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=False,
            comment="Categorias de dados cobertas pelo consentimento.",
        ),
        sa.Column(
            "status",
            sa.VARCHAR(length=255),
            server_default=sa.text("'active'::character varying"),
            autoincrement=False,
            nullable=False,
            comment="Status: active, withdrawn, expired, superseded.",
        ),
        sa.Column("consent_text", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column(
            "version",
            sa.VARCHAR(length=10),
            server_default=sa.text("'1.0'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "collection_method",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "given_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "expires_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "withdrawn_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "evidence_data",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "checksum",
            sa.VARCHAR(length=64),
            autoincrement=False,
            nullable=True,
            comment="Hash de verificação da integridade do consentimento.",
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "processing_purposes",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Finalidades específicas do consentimento",
        ),
        sa.Column(
            "is_explicit_consent",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=False,
            comment="Consentimento explícito",
        ),
        sa.Column(
            "collection_interface",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=True,
            comment="Interface de coleta (web, app, presencial)",
        ),
        sa.Column(
            "withdrawal_reason",
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
            comment="Motivo da revogação",
        ),
        sa.Column(
            "withdrawn_by_user_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=True,
            comment="Usuário que processou a revogação",
        ),
        sa.Column(
            "legal_basis_documentation",
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
            comment="Documentação da base legal",
        ),
        sa.CheckConstraint(
            "consent_type::text = ANY (ARRAY['data_processing'::character varying::text, 'marketing'::character varying::text, 'analytics'::character varying::text, 'third_party_sharing'::character varying::text, 'health_data'::character varying::text])",
            name=op.f("consent_records_consent_type_check"),
        ),
        sa.CheckConstraint(
            "status::text = ANY (ARRAY['active'::character varying::text, 'withdrawn'::character varying::text, 'expired'::character varying::text, 'superseded'::character varying::text])",
            name=op.f("consent_records_status_check"),
        ),
        sa.ForeignKeyConstraint(
            ["person_id"],
            ["people.id"],
            name=op.f("fk_consent_records_person"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("consent_records_pkey")),
        comment="Registros de consentimento para compliance LGPD/GDPR.",
    )
    op.create_index(
        op.f("idx_consent_interface"),
        "consent_records",
        ["collection_interface"],
        unique=False,
    )
    op.create_index(
        op.f("idx_consent_explicit"),
        "consent_records",
        ["is_explicit_consent"],
        unique=False,
    )
    op.create_index(
        op.f("consent_records_status_index"),
        "consent_records",
        ["status"],
        unique=False,
    )
    op.create_index(
        op.f("consent_records_person_id_index"),
        "consent_records",
        ["person_id"],
        unique=False,
    )
    op.create_index(
        op.f("consent_records_person_id_consent_type_index"),
        "consent_records",
        ["person_id", "consent_type"],
        unique=False,
    )
    op.create_index(
        op.f("consent_records_consent_type_index"),
        "consent_records",
        ["consent_type"],
        unique=False,
    )
    op.create_table(
        "establishments",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "person_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment='Referência (FK) para a identidade do estabelecimento na tabela "people" (deve ser do tipo "PJ").',
        ),
        sa.Column(
            "company_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment='Referência (FK) para a empresa mãe na tabela "companies".',
        ),
        sa.Column(
            "code",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=False,
            comment="Código único do estabelecimento dentro da empresa.",
        ),
        sa.Column(
            "type",
            sa.VARCHAR(length=255),
            server_default=sa.text("'filial'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "category", sa.VARCHAR(length=100), autoincrement=False, nullable=True
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_principal",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
            comment="Indica se é o estabelecimento principal (matriz) da empresa.",
        ),
        sa.Column(
            "settings",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "operating_hours",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "service_areas",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "type::text = ANY (ARRAY['matriz'::character varying::text, 'filial'::character varying::text, 'unidade'::character varying::text])",
            name=op.f("establishments_type_check"),
        ),
        sa.ForeignKeyConstraint(
            ["company_id"],
            ["companies.id"],
            name=op.f("fk_establishments_company"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["person_id"],
            ["people.id"],
            name=op.f("fk_establishments_person"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("establishments_pkey")),
        sa.UniqueConstraint(
            "company_id",
            "code",
            name=op.f("establishments_company_id_code_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        sa.UniqueConstraint(
            "person_id",
            name=op.f("establishments_person_id_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment='Tabela de "Papel". Define quais registros da tabela "people" são estabelecimentos vinculados a uma empresa.',
    )
    op.create_index(
        op.f("establishments_person_id_index"),
        "establishments",
        ["person_id"],
        unique=False,
    )
    op.create_index(
        op.f("establishments_deleted_at_index"),
        "establishments",
        ["deleted_at"],
        unique=False,
    )
    op.create_index(
        op.f("establishments_company_id_is_principal_index"),
        "establishments",
        ["company_id", "is_principal"],
        unique=False,
    )
    op.create_index(
        op.f("establishments_company_id_index"),
        "establishments",
        ["company_id"],
        unique=False,
    )
    op.create_table(
        "role_permissions",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "role_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID do papel que recebe a permissão",
        ),
        sa.Column(
            "permission_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID da permissão concedida",
        ),
        sa.Column(
            "granted_by_user_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=True,
            comment="ID do usuário que concedeu a permissão",
        ),
        sa.Column(
            "granted_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
            comment="Data/hora da concessão da permissão",
        ),
        sa.ForeignKeyConstraint(
            ["granted_by_user_id"],
            ["users.id"],
            name=op.f("fk_role_permissions_granted_by"),
        ),
        sa.ForeignKeyConstraint(
            ["permission_id"],
            ["permissions.id"],
            name=op.f("fk_role_permissions_permissions"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["role_id"],
            ["roles.id"],
            name=op.f("fk_role_permissions_roles"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("role_permissions_pkey")),
        sa.UniqueConstraint(
            "role_id",
            "permission_id",
            name=op.f("role_permissions_role_id_permission_id_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Relacionamento N:M entre papéis e permissões",
    )
    op.create_index(
        op.f("role_permissions_role_id_index"),
        "role_permissions",
        ["role_id"],
        unique=False,
    )
    op.create_index(
        op.f("role_permissions_permission_id_index"),
        "role_permissions",
        ["permission_id"],
        unique=False,
    )
    op.create_index(
        op.f("role_permissions_granted_by_user_id_index"),
        "role_permissions",
        ["granted_by_user_id"],
        unique=False,
    )
    op.create_index(
        op.f("role_permissions_granted_at_index"),
        "role_permissions",
        ["granted_at"],
        unique=False,
    )
    op.create_table(
        "permissions",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "name",
            sa.VARCHAR(length=125),
            autoincrement=False,
            nullable=False,
            comment="Nome único da permissão em snake_case",
        ),
        sa.Column(
            "display_name", sa.VARCHAR(length=200), autoincrement=False, nullable=False
        ),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "module",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=False,
            comment="Módulo do sistema (users, companies, reports, etc.)",
        ),
        sa.Column(
            "action",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=False,
            comment="Ação (view, create, update, delete, etc.)",
        ),
        sa.Column(
            "resource",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=False,
            comment="Recurso específico dentro do módulo",
        ),
        sa.Column(
            "context_level",
            sa.VARCHAR(length=255),
            server_default=sa.text("'establishment'::character varying"),
            autoincrement=False,
            nullable=False,
            comment="Nível de contexto da permissão",
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "context_level::text = ANY (ARRAY['system'::character varying::text, 'company'::character varying::text, 'establishment'::character varying::text])",
            name=op.f("permissions_context_level_check"),
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("permissions_pkey")),
        sa.UniqueConstraint(
            "module",
            "action",
            "resource",
            "context_level",
            name=op.f("permissions_module_action_resource_context_level_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        sa.UniqueConstraint(
            "name",
            name=op.f("permissions_name_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Permissões granulares do sistema RBAC",
    )
    op.create_index(
        op.f("permissions_name_is_active_index"),
        "permissions",
        ["name", "is_active"],
        unique=False,
    )
    op.create_index(
        op.f("permissions_module_index"), "permissions", ["module"], unique=False
    )
    op.create_index(
        op.f("permissions_module_action_index"),
        "permissions",
        ["module", "action"],
        unique=False,
    )
    op.create_index(
        op.f("permissions_is_active_index"), "permissions", ["is_active"], unique=False
    )
    op.create_index(
        op.f("permissions_context_level_index"),
        "permissions",
        ["context_level"],
        unique=False,
    )
    op.create_table(
        "cache_locks",
        sa.Column("key", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("owner", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("expiration", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.PrimaryKeyConstraint("key", name=op.f("cache_locks_pkey")),
    )
    op.create_table(
        "people",
        sa.Column(
            "id",
            sa.BIGINT(),
            server_default=sa.text("nextval('people_id_seq'::regclass)"),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column(
            "person_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Discriminador de tipo: PF (Pessoa Física) ou PJ (Pessoa Jurídica)",
        ),
        sa.Column(
            "name",
            sa.VARCHAR(length=200),
            autoincrement=False,
            nullable=False,
            comment="Nome completo (se PF) ou Razão Social (se PJ)",
        ),
        sa.Column(
            "trade_name",
            sa.VARCHAR(length=200),
            autoincrement=False,
            nullable=True,
            comment="Nome social (se PF) ou Nome Fantasia (se PJ)",
        ),
        sa.Column(
            "tax_id",
            sa.VARCHAR(length=14),
            autoincrement=False,
            nullable=False,
            comment="CPF (11 dígitos) ou CNPJ (14 dígitos), sem máscara. Único e validado matematicamente.",
        ),
        sa.Column(
            "secondary_tax_id",
            sa.VARCHAR(length=20),
            autoincrement=False,
            nullable=True,
            comment="RG (se PF) ou Inscrição Estadual (se PJ)",
        ),
        sa.Column("birth_date", sa.DATE(), autoincrement=False, nullable=True),
        sa.Column("gender", sa.VARCHAR(length=255), autoincrement=False, nullable=True),
        sa.Column(
            "marital_status", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "occupation", sa.VARCHAR(length=100), autoincrement=False, nullable=True
        ),
        sa.Column("incorporation_date", sa.DATE(), autoincrement=False, nullable=True),
        sa.Column(
            "tax_regime", sa.VARCHAR(length=50), autoincrement=False, nullable=True
        ),
        sa.Column(
            "legal_nature", sa.VARCHAR(length=100), autoincrement=False, nullable=True
        ),
        sa.Column(
            "municipal_registration",
            sa.VARCHAR(length=20),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "status",
            sa.VARCHAR(length=255),
            server_default=sa.text("'active'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "metadata",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "lgpd_consent_version",
            sa.VARCHAR(length=10),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "lgpd_consent_given_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "lgpd_data_retention_expires_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "deleted_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("website", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=True),
        sa.CheckConstraint(
            "gender::text = ANY (ARRAY['male'::character varying::text, 'female'::character varying::text, 'non_binary'::character varying::text, 'not_informed'::character varying::text])",
            name="people_gender_check",
        ),
        sa.CheckConstraint(
            "marital_status::text = ANY (ARRAY['single'::character varying::text, 'married'::character varying::text, 'divorced'::character varying::text, 'widowed'::character varying::text, 'stable_union'::character varying::text, 'not_informed'::character varying::text])",
            name="people_marital_status_check",
        ),
        sa.CheckConstraint(
            "person_type::text = ANY (ARRAY['PF'::character varying::text, 'PJ'::character varying::text])",
            name="people_person_type_check",
        ),
        sa.CheckConstraint(
            "status::text = ANY (ARRAY['active'::character varying::text, 'inactive'::character varying::text, 'pending'::character varying::text, 'suspended'::character varying::text, 'blocked'::character varying::text])",
            name="people_status_check",
        ),
        sa.PrimaryKeyConstraint("id", name="people_pkey"),
        sa.UniqueConstraint(
            "tax_id",
            name="people_tax_id_unique",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Tabela mestra unificada para entidades Físicas (PF) e Jurídicas (PJ). Fonte única de verdade para dados cadastrais.",
        postgresql_ignore_search_path=False,
    )
    op.create_index(op.f("people_status_index"), "people", ["status"], unique=False)
    op.create_index(
        op.f("people_person_type_index"), "people", ["person_type"], unique=False
    )
    op.create_index(op.f("people_name_index"), "people", ["name"], unique=False)
    op.create_index(
        op.f("people_metadata_fulltext"),
        "people",
        [sa.literal_column("to_tsvector('english'::regconfig, metadata)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("people_deleted_at_index"), "people", ["deleted_at"], unique=False
    )
    op.create_table(
        "tenant_features",
        sa.Column("id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column(
            "tenant_type",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Tipo do tenant: company ou establishment.",
        ),
        sa.Column(
            "tenant_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID da empresa ou estabelecimento.",
        ),
        sa.Column(
            "feature_key",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=False,
            comment="Chave única da funcionalidade (ex: scheduling.advanced).",
        ),
        sa.Column(
            "is_enabled",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
            comment="Se a funcionalidade está habilitada.",
        ),
        sa.Column(
            "usage_limit",
            sa.INTEGER(),
            autoincrement=False,
            nullable=True,
            comment="Limite de uso (NULL = ilimitado).",
        ),
        sa.Column(
            "current_usage",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
            comment="Uso atual da funcionalidade.",
        ),
        sa.Column(
            "feature_config",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Configurações específicas da funcionalidade em JSONB.",
        ),
        sa.Column(
            "enabled_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "expires_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_by_user_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=True,
            comment="ID da conta de acesso (usuário) que fez a última alteração.",
        ),
        sa.CheckConstraint(
            "tenant_type::text = ANY (ARRAY['company'::character varying::text, 'establishment'::character varying::text])",
            name=op.f("tenant_features_tenant_type_check"),
        ),
        sa.ForeignKeyConstraint(
            ["updated_by_user_id"],
            ["users.id"],
            name=op.f("fk_tenant_features_updated_by"),
            ondelete="SET NULL",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("tenant_features_pkey")),
        sa.UniqueConstraint(
            "tenant_type",
            "tenant_id",
            "feature_key",
            name=op.f("tenant_features_tenant_type_tenant_id_feature_key_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Controle de funcionalidades habilitadas por empresa/estabelecimento.",
    )
    op.create_index(
        op.f("tenant_features_tenant_type_tenant_id_is_enabled_index"),
        "tenant_features",
        ["tenant_type", "tenant_id", "is_enabled"],
        unique=False,
    )
    op.create_index(
        op.f("tenant_features_tenant_type_tenant_id_index"),
        "tenant_features",
        ["tenant_type", "tenant_id"],
        unique=False,
    )
    op.create_index(
        op.f("tenant_features_feature_key_index"),
        "tenant_features",
        ["feature_key"],
        unique=False,
    )
    op.create_index(
        op.f("tenant_features_feature_config_fulltext"),
        "tenant_features",
        [sa.literal_column("to_tsvector('english'::regconfig, feature_config)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("tenant_features_expires_at_index"),
        "tenant_features",
        ["expires_at"],
        unique=False,
    )
    op.create_table(
        "sessions",
        sa.Column("id", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("user_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column(
            "ip_address", sa.VARCHAR(length=45), autoincrement=False, nullable=True
        ),
        sa.Column("user_agent", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column("payload", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("last_activity", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.PrimaryKeyConstraint("id", name=op.f("sessions_pkey")),
        schema="public",
    )
    op.create_index(
        op.f("sessions_user_id_index"),
        "sessions",
        ["user_id"],
        unique=False,
        schema="public",
    )
    op.create_index(
        op.f("sessions_last_activity_index"),
        "sessions",
        ["last_activity"],
        unique=False,
        schema="public",
    )
    op.create_table(
        "activity_logs_2025_08",
        sa.Column("id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column(
            "log_name", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column(
            "subject_type", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column("subject_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column("event", sa.VARCHAR(length=255), autoincrement=False, nullable=True),
        sa.Column(
            "causer_type", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column("causer_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column(
            "context_type", sa.VARCHAR(length=20), autoincrement=False, nullable=True
        ),
        sa.Column("context_id", sa.BIGINT(), autoincrement=False, nullable=True),
        sa.Column(
            "properties",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("batch_uuid", sa.UUID(), autoincrement=False, nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=False,
        ),
        sa.PrimaryKeyConstraint(
            "id", "created_at", name=op.f("activity_logs_2025_08_pkey")
        ),
    )
    op.create_index(
        op.f("activity_logs_2025_08_subject_type_subject_id_index"),
        "activity_logs_2025_08",
        ["subject_type", "subject_id"],
        unique=False,
    )
    op.create_index(
        op.f("activity_logs_2025_08_log_name_index"),
        "activity_logs_2025_08",
        ["log_name"],
        unique=False,
    )
    op.create_index(
        op.f("activity_logs_2025_08_created_at_index"),
        "activity_logs_2025_08",
        ["created_at"],
        unique=False,
    )
    op.create_index(
        op.f("activity_logs_2025_08_causer_type_causer_id_index"),
        "activity_logs_2025_08",
        ["causer_type", "causer_id"],
        unique=False,
    )
    op.create_table(
        "query_audit_logs",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column(
            "timestamp",
            postgresql.TIMESTAMP(timezone=True, precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "user_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="Usuário que executou a consulta",
        ),
        sa.Column(
            "ip_address",
            sa.VARCHAR(length=45),
            autoincrement=False,
            nullable=False,
            comment="IP de origem",
        ),
        sa.Column(
            "session_id", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "table_accessed",
            sa.VARCHAR(length=63),
            autoincrement=False,
            nullable=False,
            comment="Tabela consultada",
        ),
        sa.Column(
            "records_accessed",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="IDs dos registros acessados",
        ),
        sa.Column(
            "records_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
            comment="Quantidade de registros retornados",
        ),
        sa.Column(
            "query_purpose",
            sa.TEXT(),
            autoincrement=False,
            nullable=False,
            comment="Finalidade da consulta",
        ),
        sa.Column(
            "lawful_basis",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Base legal da consulta",
        ),
        sa.Column(
            "data_sensitivity_level",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
            comment="Nível de sensibilidade dos dados consultados",
        ),
        sa.Column(
            "access_context",
            sa.VARCHAR(length=200),
            autoincrement=False,
            nullable=True,
            comment="Contexto da consulta (tela, relatório, etc)",
        ),
        sa.Column(
            "application_module",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=True,
            comment="Módulo do sistema",
        ),
        sa.CheckConstraint(
            "data_sensitivity_level::text = ANY (ARRAY['public'::character varying::text, 'internal'::character varying::text, 'confidential'::character varying::text, 'sensitive_personal'::character varying::text, 'highly_sensitive'::character varying::text])",
            name=op.f("query_audit_logs_data_sensitivity_level_check"),
        ),
        sa.CheckConstraint(
            "lawful_basis::text = ANY (ARRAY['consent'::character varying::text, 'contract'::character varying::text, 'legal_obligation'::character varying::text, 'vital_interests'::character varying::text, 'public_task'::character varying::text, 'legitimate_interests'::character varying::text, 'credit_protection'::character varying::text])",
            name=op.f("query_audit_logs_lawful_basis_check"),
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.id"],
            name=op.f("fk_query_logs_user"),
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("query_audit_logs_pkey")),
        comment="Logs de auditoria para consultas (SELECT) - Obrigatório ANPD 2025",
    )
    op.create_index(
        op.f("master_query_audit_logs_user_id_index"),
        "query_audit_logs",
        ["user_id"],
        unique=False,
    )
    op.create_index(
        op.f("master_query_audit_logs_table_accessed_index"),
        "query_audit_logs",
        ["table_accessed"],
        unique=False,
    )
    op.create_index(
        op.f("master_query_audit_logs_session_id_index"),
        "query_audit_logs",
        ["session_id"],
        unique=False,
    )
    op.create_index(
        op.f("idx_query_logs_user_time"),
        "query_audit_logs",
        ["user_id", "timestamp"],
        unique=False,
    )
    op.create_index(
        op.f("idx_query_logs_timestamp"),
        "query_audit_logs",
        ["timestamp"],
        unique=False,
    )
    op.create_index(
        op.f("idx_query_logs_table_time"),
        "query_audit_logs",
        ["table_accessed", "timestamp"],
        unique=False,
    )
    op.create_index(
        op.f("idx_query_logs_sensitivity"),
        "query_audit_logs",
        ["data_sensitivity_level"],
        unique=False,
    )
    op.create_table(
        "jobs",
        sa.Column("id", sa.BIGINT(), autoincrement=True, nullable=False),
        sa.Column("queue", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("payload", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("attempts", sa.SMALLINT(), autoincrement=False, nullable=False),
        sa.Column("reserved_at", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column("available_at", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("created_at", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.PrimaryKeyConstraint("id", name=op.f("jobs_pkey")),
        comment="Fila de jobs assíncronos do Laravel.",
    )
    op.create_index(op.f("master_jobs_queue_index"), "jobs", ["queue"], unique=False)
    op.create_table(
        "company_settings",
        sa.Column("id", sa.BIGINT(), autoincrement=False, nullable=False),
        sa.Column(
            "company_id",
            sa.BIGINT(),
            autoincrement=False,
            nullable=False,
            comment="ID da empresa proprietária da configuração.",
        ),
        sa.Column(
            "setting_key",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=False,
            comment="Chave única da configuração (ex: notification.email.enabled).",
        ),
        sa.Column(
            "setting_category",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=False,
            comment="Categoria da configuração (ex: notification, security, ui).",
        ),
        sa.Column(
            "setting_value",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
            comment="Valor atual da configuração em formato JSONB.",
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(precision=0),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(precision=0),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_by_user_id", sa.BIGINT(), autoincrement=False, nullable=True
        ),
        sa.ForeignKeyConstraint(
            ["company_id"],
            ["companies.id"],
            name=op.f("fk_company_settings_company"),
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["updated_by_user_id"],
            ["users.id"],
            name=op.f("fk_company_settings_updated_by"),
            ondelete="SET NULL",
        ),
        sa.PrimaryKeyConstraint("id", name=op.f("company_settings_pkey")),
        sa.UniqueConstraint(
            "company_id",
            "setting_key",
            name=op.f("company_settings_company_id_setting_key_unique"),
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="Configurações específicas por empresa no sistema multi-tenant (modelo EAV).",
    )
    op.create_index(
        op.f("company_settings_updated_by_user_id_index"),
        "company_settings",
        ["updated_by_user_id"],
        unique=False,
    )
    op.create_index(
        op.f("company_settings_setting_value_fulltext"),
        "company_settings",
        [sa.literal_column("to_tsvector('english'::regconfig, setting_value)")],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        op.f("company_settings_setting_key_index"),
        "company_settings",
        ["setting_key"],
        unique=False,
    )
    op.create_index(
        op.f("company_settings_setting_category_index"),
        "company_settings",
        ["setting_category"],
        unique=False,
    )
    op.create_index(
        op.f("company_settings_company_id_index"),
        "company_settings",
        ["company_id"],
        unique=False,
    )
    # ### end Alembic commands ###
