# üìã An√°lise: Sistema de Contratos Home Care com M√∫ltiplas Vidas

## üéØ Cen√°rios de Neg√≥cio

### 1. **Pessoa F√≠sica Individual**
- **Cliente**: Jo√£o Silva (CPF: 123.456.789-00)
- **Vidas**: Titular + dependentes (esposa, 2 filhos)
- **Caracter√≠sticas**: Vidas fixas, altera√ß√µes raras, plano familiar

### 2. **Pessoa Jur√≠dica Corporativa**
- **Cliente**: UNIMED Regional (CNPJ: 12.345.678/0001-90)
- **Vidas**: 10 funcion√°rios/m√™s (rotatividade permitida)
- **Caracter√≠sticas**: Quantidade fixa, lista flex√≠vel, controle mensal

### 3. **Pessoa F√≠sica Empres√°rio**
- **Cliente**: Dr. Carlos (CPF) - Cl√≠nica m√©dica
- **Vidas**: Equipe cl√≠nica (5 pessoas)
- **Caracter√≠sticas**: Pequeno porte, flexibilidade limitada

## üèóÔ∏è Estrutura Proposta

### **Hierarquia Cliente ‚Üí Contrato ‚Üí Servi√ßos ‚Üí Vida ‚Üí Servi√ßos Espec√≠ficos**

```
CLIENTE (PF/PJ)
‚îú‚îÄ‚îÄ CONTRATO 1 (Plano B√°sico - 10 vidas)
‚îÇ   ‚îú‚îÄ‚îÄ SERVI√áOS PERMITIDOS NO CONTRATO
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ENF001: Aplica√ß√£o Medica√ß√£o EV (at√© 4/m√™s por vida)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ENF002: Curativo Simples (at√© 8/m√™s por vida)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FIS001: Fisioterapia Motora (at√© 8/m√™s por vida)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MED001: Consulta M√©dica (1/m√™s por vida)
‚îÇ   ‚îú‚îÄ‚îÄ VIDA 1 (Maria Silva - Diab√©tica)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚úÖ ENF001: Autorizada (insulina 2x/dia)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚úÖ ENF002: Autorizada
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚ùå FIS001: N√£o autorizada (sem indica√ß√£o)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ‚úÖ MED001: Autorizada
‚îÇ   ‚îú‚îÄ‚îÄ VIDA 2 (Jo√£o Santos - P√≥s-cir√∫rgico)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚úÖ ENF001: Autorizada (antibi√≥tico)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚úÖ ENF002: Autorizada (curativo cir√∫rgico)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚úÖ FIS001: Autorizada (reabilita√ß√£o)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ‚úÖ MED001: Autorizada
‚îÇ   ‚îî‚îÄ‚îÄ VIDA 3 (Ana Costa - Idosa)
‚îÇ       ‚îú‚îÄ‚îÄ ‚ùå ENF001: N√£o autorizada
‚îÇ       ‚îú‚îÄ‚îÄ ‚úÖ ENF002: Autorizada (√∫lceras)
‚îÇ       ‚îú‚îÄ‚îÄ ‚úÖ FIS001: Autorizada (mobilidade)
‚îÇ       ‚îî‚îÄ‚îÄ ‚úÖ MED001: Autorizada
```

## üìä Modelagem de Dados

### **1. Tabela: contracts**
```sql
CREATE TABLE contracts (
    id SERIAL PRIMARY KEY,
    client_id INTEGER NOT NULL REFERENCES clients(id),
    contract_number VARCHAR(50) UNIQUE NOT NULL,
    contract_type VARCHAR(20) NOT NULL CHECK (contract_type IN ('INDIVIDUAL', 'CORPORATIVO', 'EMPRESARIAL')),

    -- Controle de Vidas
    lives_contracted INTEGER NOT NULL DEFAULT 1,
    lives_minimum INTEGER DEFAULT NULL, -- toler√¢ncia m√≠nima
    lives_maximum INTEGER DEFAULT NULL, -- toler√¢ncia m√°xima

    -- Flexibilidade
    allows_substitution BOOLEAN DEFAULT false,
    control_period VARCHAR(10) DEFAULT 'MONTHLY' CHECK (control_period IN ('DAILY', 'WEEKLY', 'MONTHLY', 'QUARTERLY')),

    -- Dados do Contrato
    plan_name VARCHAR(100) NOT NULL,
    monthly_value DECIMAL(10,2) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE,

    -- Localiza√ß√£o
    service_addresses JSONB, -- m√∫ltiplos endere√ßos de atendimento

    -- Status
    status VARCHAR(20) DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE', 'SUSPENDED', 'CANCELLED', 'EXPIRED')),

    -- Auditoria
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INTEGER REFERENCES users(id),
    updated_by INTEGER REFERENCES users(id)
);
```

### **2. Tabela: contract_lives**
```sql
CREATE TABLE contract_lives (
    id SERIAL PRIMARY KEY,
    contract_id INTEGER NOT NULL REFERENCES contracts(id),
    person_id INTEGER NOT NULL REFERENCES people(id),

    -- Per√≠odo de Vincula√ß√£o
    start_date DATE NOT NULL,
    end_date DATE, -- NULL = ativa

    -- Tipo de Rela√ß√£o
    relationship_type VARCHAR(20) NOT NULL CHECK (relationship_type IN ('TITULAR', 'DEPENDENTE', 'FUNCIONARIO', 'BENEFICIARIO')),

    -- Status
    status VARCHAR(20) DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE', 'INACTIVE', 'SUBSTITUTED', 'CANCELLED')),
    substitution_reason VARCHAR(100),

    -- Localiza√ß√£o Espec√≠fica
    primary_service_address JSONB,

    -- Auditoria
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INTEGER REFERENCES users(id),

    -- Constraints
    UNIQUE(contract_id, person_id, start_date) -- mesma pessoa pode ter per√≠odos diferentes
);
```

### **3. Tabela: contract_lives_history**
```sql
CREATE TABLE contract_lives_history (
    id SERIAL PRIMARY KEY,
    contract_id INTEGER NOT NULL,
    person_id INTEGER NOT NULL,
    action_type VARCHAR(20) NOT NULL CHECK (action_type IN ('ADDED', 'REMOVED', 'SUBSTITUTED', 'REACTIVATED')),
    action_date DATE NOT NULL,
    reason VARCHAR(200),
    previous_person_id INTEGER, -- em caso de substitui√ß√£o

    -- Contexto no momento da a√ß√£o
    lives_count_before INTEGER,
    lives_count_after INTEGER,

    -- Auditoria
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INTEGER REFERENCES users(id)
);
```

### **4. View: contract_current_lives**
```sql
CREATE VIEW contract_current_lives AS
SELECT
    cl.contract_id,
    cl.person_id,
    p.name as person_name,
    p.document_number,
    cl.relationship_type,
    cl.start_date,
    cl.primary_service_address,
    c.lives_contracted,
    c.lives_minimum,
    c.lives_maximum
FROM contract_lives cl
JOIN people p ON cl.person_id = p.id
JOIN contracts c ON cl.contract_id = c.id
WHERE cl.status = 'ACTIVE'
  AND cl.end_date IS NULL
  AND c.status = 'ACTIVE';
```

## üí° Solu√ß√£o para Cen√°rio UNIMED

### **Caso: "10 vidas/m√™s com rotatividade"**

```sql
-- 1. Criar contrato flex√≠vel
INSERT INTO contracts (
    client_id, contract_number, contract_type,
    lives_contracted, lives_minimum, lives_maximum,
    allows_substitution, control_period,
    plan_name, monthly_value, start_date
) VALUES (
    65, 'UNIMED-2025-001', 'CORPORATIVO',
    10, 8, 12,  -- 10 vidas, toler√¢ncia ¬±2
    true, 'MONTHLY',
    'Plano Corporativo UNIMED', 15000.00, '2025-01-01'
);

-- 2. Adicionar vidas iniciais
INSERT INTO contract_lives (contract_id, person_id, start_date, relationship_type) VALUES
(1001, 201, '2025-01-01', 'FUNCIONARIO'),
(1001, 202, '2025-01-01', 'FUNCIONARIO'),
-- ... at√© 10 pessoas

-- 3. Substitui√ß√£o em 15/01 (Ana sai, Pedro entra)
UPDATE contract_lives
SET status = 'SUBSTITUTED', end_date = '2025-01-15', substitution_reason = 'Desligamento da empresa'
WHERE contract_id = 1001 AND person_id = 203;

INSERT INTO contract_lives (contract_id, person_id, start_date, relationship_type) VALUES
(1001, 204, '2025-01-16', 'FUNCIONARIO');

-- 4. Registrar hist√≥rico
INSERT INTO contract_lives_history (contract_id, person_id, action_type, action_date, reason, previous_person_id, lives_count_before, lives_count_after, created_by) VALUES
(1001, 203, 'REMOVED', '2025-01-15', 'Desligamento da empresa', NULL, 10, 9, 1),
(1001, 204, 'SUBSTITUTED', '2025-01-16', 'Substitui√ß√£o por novo funcion√°rio', 203, 9, 10, 1);
```

## üè• Gest√£o de Servi√ßos Home Care

### **Estrutura de Servi√ßos**

**N√≠vel 1: Cat√°logo de Servi√ßos (Global)**
- Todos os servi√ßos dispon√≠veis na empresa
- Caracter√≠sticas, limita√ß√µes e valores padr√£o

**N√≠vel 2: Servi√ßos do Contrato**
- Quais servi√ßos est√£o inclusos no contrato
- Limites e valores espec√≠ficos por contrato

**N√≠vel 3: Servi√ßos por Vida**
- Personaliza√ß√£o m√©dica individual
- Autoriza√ß√µes e restri√ß√µes espec√≠ficas

### **1. Tabela: services_catalog**
```sql
CREATE TABLE services_catalog (
    id SERIAL PRIMARY KEY,
    service_code VARCHAR(20) UNIQUE NOT NULL,
    service_name VARCHAR(100) NOT NULL,
    service_category VARCHAR(50) NOT NULL, -- 'ENFERMAGEM', 'FISIOTERAPIA', 'MEDICINA', 'NUTRI√á√ÉO'
    service_type VARCHAR(30) NOT NULL, -- 'VISITA', 'PROCEDIMENTO', 'MEDICA√á√ÉO', 'EQUIPAMENTO'

    -- Caracter√≠sticas do Servi√ßo
    requires_prescription BOOLEAN DEFAULT false,
    requires_specialist BOOLEAN DEFAULT false,
    home_visit_required BOOLEAN DEFAULT true,

    -- Valores e Controle
    default_unit_value DECIMAL(10,2),
    billing_unit VARCHAR(20) DEFAULT 'UNIT', -- 'UNIT', 'HOUR', 'DAY', 'MONTH'

    -- Regulamenta√ß√µes
    anvisa_regulated BOOLEAN DEFAULT false,
    requires_authorization BOOLEAN DEFAULT false,

    -- Status
    status VARCHAR(20) DEFAULT 'ACTIVE',

    -- Auditoria
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Exemplos de servi√ßos
INSERT INTO services_catalog (service_code, service_name, service_category, service_type, requires_prescription, home_visit_required, default_unit_value) VALUES
('ENF001', 'Aplica√ß√£o de Medica√ß√£o EV', 'ENFERMAGEM', 'PROCEDIMENTO', true, true, 80.00),
('ENF002', 'Curativo Simples', 'ENFERMAGEM', 'PROCEDIMENTO', false, true, 45.00),
('ENF003', 'Coleta de Sangue', 'ENFERMAGEM', 'EXAME', false, true, 35.00),
('FIS001', 'Fisioterapia Motora', 'FISIOTERAPIA', 'TERAPIA', true, true, 120.00),
('MED001', 'Consulta M√©dica Domiciliar', 'MEDICINA', 'CONSULTA', false, true, 250.00),
('EQP001', 'Loca√ß√£o Cama Hospitalar', 'EQUIPAMENTO', 'LOCA√á√ÉO', false, false, 300.00),
('NUT001', 'Consulta Nutricional', 'NUTRI√á√ÉO', 'CONSULTA', false, true, 150.00),
('PSI001', 'Atendimento Psicol√≥gico', 'PSICOLOGIA', 'CONSULTA', false, true, 120.00);
```

### **2. Tabela: contract_services**
```sql
CREATE TABLE contract_services (
    id SERIAL PRIMARY KEY,
    contract_id INTEGER NOT NULL REFERENCES contracts(id),
    service_id INTEGER NOT NULL REFERENCES services_catalog(id),

    -- Limites e Controles do Contrato
    monthly_limit INTEGER, -- quantidade m√°xima por m√™s por vida (NULL = ilimitado)
    daily_limit INTEGER,   -- quantidade m√°xima por dia por vida
    annual_limit INTEGER,  -- limite anual por vida

    -- Valores Espec√≠ficos do Contrato
    unit_value DECIMAL(10,2), -- valor espec√≠fico para este contrato
    requires_pre_authorization BOOLEAN DEFAULT false,

    -- Per√≠odo de Validade
    start_date DATE NOT NULL,
    end_date DATE,

    -- Status
    status VARCHAR(20) DEFAULT 'ACTIVE',

    -- Auditoria
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER REFERENCES users(id),

    UNIQUE(contract_id, service_id, start_date)
);
```

### **3. Tabela: contract_life_services**
```sql
CREATE TABLE contract_life_services (
    id SERIAL PRIMARY KEY,
    contract_life_id INTEGER NOT NULL REFERENCES contract_lives(id),
    service_id INTEGER NOT NULL REFERENCES services_catalog(id),

    -- Autoriza√ß√£o Individual
    is_authorized BOOLEAN DEFAULT true,
    authorization_date DATE,
    authorized_by INTEGER REFERENCES users(id), -- m√©dico respons√°vel

    -- Limites Individuais (sobrep√µem os do contrato)
    monthly_limit_override INTEGER,
    daily_limit_override INTEGER,
    annual_limit_override INTEGER,

    -- Dados M√©dicos
    medical_indication TEXT,
    contraindications TEXT,
    special_instructions TEXT,
    priority_level VARCHAR(20) DEFAULT 'NORMAL', -- 'URGENT', 'HIGH', 'NORMAL', 'LOW'

    -- Per√≠odo de Autoriza√ß√£o
    start_date DATE NOT NULL,
    end_date DATE,

    -- Status
    status VARCHAR(20) DEFAULT 'ACTIVE',

    -- Auditoria
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INTEGER REFERENCES users(id),

    UNIQUE(contract_life_id, service_id, start_date)
);
```

### **4. Tabela: service_executions**
```sql
CREATE TABLE service_executions (
    id SERIAL PRIMARY KEY,
    contract_life_id INTEGER NOT NULL REFERENCES contract_lives(id),
    service_id INTEGER NOT NULL REFERENCES services_catalog(id),

    -- Dados da Execu√ß√£o
    execution_date TIMESTAMP NOT NULL,
    professional_id INTEGER REFERENCES users(id),

    -- Detalhes da Execu√ß√£o
    quantity DECIMAL(8,2) DEFAULT 1,
    unit_value DECIMAL(10,2) NOT NULL,
    total_value DECIMAL(10,2) GENERATED ALWAYS AS (quantity * unit_value) STORED,

    -- Localiza√ß√£o
    service_address JSONB,
    arrival_time TIMESTAMP,
    departure_time TIMESTAMP,
    duration_minutes INTEGER,

    -- Observa√ß√µes Cl√≠nicas
    execution_notes TEXT,
    patient_response TEXT,
    complications TEXT,
    materials_used JSONB,

    -- Controle de Qualidade
    quality_score INTEGER CHECK (quality_score BETWEEN 1 AND 5),
    family_satisfaction INTEGER CHECK (family_satisfaction BETWEEN 1 AND 5),

    -- Status
    status VARCHAR(20) DEFAULT 'EXECUTED', -- 'SCHEDULED', 'EXECUTED', 'CANCELLED', 'NO_SHOW'
    cancellation_reason TEXT,

    -- Auditoria
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by INTEGER REFERENCES users(id)
);
```

## üìä Views de Controle

### **1. Servi√ßos Dispon√≠veis por Vida**
```sql
CREATE VIEW available_services_per_life AS
SELECT
    cl.id as contract_life_id,
    cl.contract_id,
    p.name as person_name,
    p.document_number,
    sc.service_code,
    sc.service_name,
    sc.service_category,
    sc.service_type,

    -- Limites do Contrato
    cs.monthly_limit as contract_monthly_limit,
    cs.daily_limit as contract_daily_limit,
    cs.annual_limit as contract_annual_limit,
    cs.unit_value as contract_unit_value,

    -- Limites Espec√≠ficos da Vida (override)
    COALESCE(cls.monthly_limit_override, cs.monthly_limit) as effective_monthly_limit,
    COALESCE(cls.daily_limit_override, cs.daily_limit) as effective_daily_limit,
    COALESCE(cls.annual_limit_override, cs.annual_limit) as effective_annual_limit,

    -- Status de Autoriza√ß√£o
    COALESCE(cls.is_authorized, true) as is_authorized,
    cls.medical_indication,
    cls.special_instructions,
    cls.priority_level,

    -- Dados do Servi√ßo
    sc.requires_prescription,
    sc.requires_specialist,
    sc.home_visit_required

FROM contract_lives cl
JOIN people p ON cl.person_id = p.id
JOIN contracts c ON cl.contract_id = c.id
JOIN contract_services cs ON c.id = cs.contract_id
JOIN services_catalog sc ON cs.service_id = sc.id
LEFT JOIN contract_life_services cls ON cl.id = cls.contract_life_id AND sc.id = cls.service_id

WHERE cl.status = 'ACTIVE'
  AND cl.end_date IS NULL
  AND cs.status = 'ACTIVE'
  AND (cs.end_date IS NULL OR cs.end_date >= CURRENT_DATE)
  AND (cls.status IS NULL OR cls.status = 'ACTIVE')
  AND (cls.end_date IS NULL OR cls.end_date >= CURRENT_DATE)
  AND sc.status = 'ACTIVE';
```

### **2. Controle de Consumo por Per√≠odo**
```sql
CREATE VIEW service_consumption_control AS
SELECT
    cl.id as contract_life_id,
    p.name as person_name,
    se.service_id,
    sc.service_name,

    -- Consumo Di√°rio
    COUNT(CASE WHEN se.execution_date::DATE = CURRENT_DATE AND se.status = 'EXECUTED' THEN 1 END) as today_count,

    -- Consumo Mensal
    COUNT(CASE WHEN DATE_TRUNC('month', se.execution_date) = DATE_TRUNC('month', CURRENT_DATE) AND se.status = 'EXECUTED' THEN 1 END) as month_count,

    -- Consumo Anual
    COUNT(CASE WHEN DATE_TRUNC('year', se.execution_date) = DATE_TRUNC('year', CURRENT_DATE) AND se.status = 'EXECUTED' THEN 1 END) as year_count,

    -- Valores
    SUM(CASE WHEN DATE_TRUNC('month', se.execution_date) = DATE_TRUNC('month', CURRENT_DATE) AND se.status = 'EXECUTED' THEN se.total_value ELSE 0 END) as month_value,

    -- Qualidade
    AVG(CASE WHEN se.quality_score IS NOT NULL AND se.status = 'EXECUTED' THEN se.quality_score END) as avg_quality_score,
    AVG(CASE WHEN se.family_satisfaction IS NOT NULL AND se.status = 'EXECUTED' THEN se.family_satisfaction END) as avg_satisfaction

FROM contract_lives cl
JOIN people p ON cl.person_id = p.id
LEFT JOIN service_executions se ON cl.id = se.contract_life_id
LEFT JOIN services_catalog sc ON se.service_id = sc.id
WHERE cl.status = 'ACTIVE' AND cl.end_date IS NULL
GROUP BY cl.id, p.name, se.service_id, sc.service_name;
```

## üéØ Exemplo Pr√°tico: Contrato UNIMED

```sql
-- 1. Criar contrato UNIMED com servi√ßos
INSERT INTO contracts (client_id, contract_number, contract_type, lives_contracted, allows_substitution, plan_name, monthly_value)
VALUES (65, 'UNIMED-2025-001', 'CORPORATIVO', 10, true, 'Plano Home Care Corporativo', 15000.00);

-- 2. Definir servi√ßos permitidos no contrato
INSERT INTO contract_services (contract_id, service_id, monthly_limit, unit_value, requires_pre_authorization) VALUES
(1001, 1, 4, 80.00, false),    -- ENF001: At√© 4 aplica√ß√µes EV por m√™s por vida
(1001, 2, 8, 45.00, false),    -- ENF002: At√© 8 curativos por m√™s por vida
(1001, 3, 2, 35.00, false),    -- ENF003: At√© 2 coletas por m√™s por vida
(1001, 4, 8, 120.00, true),    -- FIS001: At√© 8 sess√µes de fisio por m√™s (precisa autoriza√ß√£o)
(1001, 5, 1, 250.00, false),   -- MED001: 1 consulta m√©dica por m√™s por vida
(1001, 7, 1, 150.00, true);    -- NUT001: 1 consulta nutricional por m√™s (precisa autoriza√ß√£o)

-- 3. Adicionar vida ao contrato (Maria - Diab√©tica)
INSERT INTO contract_lives (contract_id, person_id, start_date, relationship_type)
VALUES (1001, 201, '2025-01-01', 'FUNCIONARIO');

-- 4. Personalizar servi√ßos para Maria (diab√©tica)
INSERT INTO contract_life_services (contract_life_id, service_id, medical_indication, special_instructions, is_authorized, priority_level) VALUES
(2001, 1, 'Diabetes tipo 2 - insulina NPH e regular', 'Aplicar conforme prescri√ß√£o m√©dica. NPH pela manh√£, regular antes das refei√ß√µes', true, 'HIGH'),
(2001, 3, 'Controle glic√™mico - HbA1c e glicemia', 'Coleta mensal para hemoglobina glicada e glicemia de jejum', true, 'NORMAL'),
(2001, 7, 'Orienta√ß√£o nutricional para diabetes', 'Dieta para controle glic√™mico', true, 'NORMAL');

-- 5. Restringir fisioterapia para Maria (n√£o tem indica√ß√£o)
INSERT INTO contract_life_services (contract_life_id, service_id, is_authorized, medical_indication)
VALUES (2001, 4, false, 'Sem indica√ß√£o cl√≠nica atual');

-- 6. Registrar execu√ß√£o de servi√ßos
INSERT INTO service_executions (contract_life_id, service_id, execution_date, professional_id, unit_value, execution_notes, quality_score) VALUES
(2001, 1, '2025-01-15 08:00:00', 10, 80.00, 'Aplica√ß√£o de insulina NPH - 20UI subcut√¢nea', 5),
(2001, 1, '2025-01-15 18:00:00', 10, 80.00, 'Aplica√ß√£o de insulina regular - 8UI subcut√¢nea', 5),
(2001, 3, '2025-01-20 07:00:00', 12, 35.00, 'Coleta para glicemia de jejum - paciente em jejum h√° 12h', 4);
```

## üîç Fun√ß√µes de Valida√ß√£o

### **Valida√ß√£o de Limites de Servi√ßo**
```sql
CREATE OR REPLACE FUNCTION validate_service_limits(
    p_contract_life_id INTEGER,
    p_service_id INTEGER,
    p_execution_date DATE,
    p_quantity DECIMAL DEFAULT 1
) RETURNS TEXT AS $$
DECLARE
    daily_used DECIMAL;
    monthly_used DECIMAL;
    annual_used DECIMAL;
    daily_limit INTEGER;
    monthly_limit INTEGER;
    annual_limit INTEGER;
    is_authorized BOOLEAN;
    result TEXT;
BEGIN
    -- Buscar limites efetivos e autoriza√ß√£o
    SELECT
        effective_daily_limit,
        effective_monthly_limit,
        effective_annual_limit,
        is_authorized
    INTO daily_limit, monthly_limit, annual_limit, is_authorized
    FROM available_services_per_life
    WHERE contract_life_id = p_contract_life_id
      AND service_id = p_service_id;

    -- Verificar se servi√ßo est√° autorizado
    IF NOT COALESCE(is_authorized, false) THEN
        RETURN 'SERVICE_NOT_AUTHORIZED';
    END IF;

    -- Verificar uso di√°rio
    SELECT COALESCE(SUM(quantity), 0)
    INTO daily_used
    FROM service_executions
    WHERE contract_life_id = p_contract_life_id
      AND service_id = p_service_id
      AND execution_date::DATE = p_execution_date
      AND status = 'EXECUTED';

    -- Verificar uso mensal
    SELECT COALESCE(SUM(quantity), 0)
    INTO monthly_used
    FROM service_executions
    WHERE contract_life_id = p_contract_life_id
      AND service_id = p_service_id
      AND DATE_TRUNC('month', execution_date) = DATE_TRUNC('month', p_execution_date)
      AND status = 'EXECUTED';

    -- Verificar uso anual
    SELECT COALESCE(SUM(quantity), 0)
    INTO annual_used
    FROM service_executions
    WHERE contract_life_id = p_contract_life_id
      AND service_id = p_service_id
      AND DATE_TRUNC('year', execution_date) = DATE_TRUNC('year', p_execution_date)
      AND status = 'EXECUTED';

    -- Validar limites
    IF daily_limit IS NOT NULL AND (daily_used + p_quantity) > daily_limit THEN
        result := 'DAILY_LIMIT_EXCEEDED';
    ELSIF monthly_limit IS NOT NULL AND (monthly_used + p_quantity) > monthly_limit THEN
        result := 'MONTHLY_LIMIT_EXCEEDED';
    ELSIF annual_limit IS NOT NULL AND (annual_used + p_quantity) > annual_limit THEN
        result := 'ANNUAL_LIMIT_EXCEEDED';
    ELSE
        result := 'WITHIN_LIMITS';
    END IF;

    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

## üîÑ Controle de Rotatividade

### **Regras de Neg√≥cio**

1. **Valida√ß√£o Mensal**: Verificar quantidade no √∫ltimo dia do m√™s
2. **Toler√¢ncia**: Permitir varia√ß√£o dentro dos limites (¬±2 vidas)
3. **Substitui√ß√£o**: Livre durante o m√™s para contratos flex√≠veis
4. **Faturamento**: Sempre baseado na quantidade contratada
5. **Hist√≥rico**: Rastrear todas as altera√ß√µes para auditoria

### **Fun√ß√µes de Controle**

```sql
-- Fun√ß√£o: Validar quantidade de vidas no m√™s
CREATE OR REPLACE FUNCTION validate_contract_lives_month(
    p_contract_id INTEGER,
    p_year_month DATE
) RETURNS TEXT AS $$
DECLARE
    active_lives INTEGER;
    contract_data RECORD;
    result TEXT;
BEGIN
    -- Buscar dados do contrato
    SELECT lives_contracted, lives_minimum, lives_maximum
    INTO contract_data
    FROM contracts
    WHERE id = p_contract_id;

    -- Contar vidas ativas no per√≠odo
    SELECT COUNT(*)
    INTO active_lives
    FROM contract_lives cl
    WHERE cl.contract_id = p_contract_id
      AND cl.start_date <= (p_year_month + INTERVAL '1 month' - INTERVAL '1 day')
      AND (cl.end_date IS NULL OR cl.end_date >= p_year_month)
      AND cl.status = 'ACTIVE';

    -- Validar limites
    IF active_lives < COALESCE(contract_data.lives_minimum, contract_data.lives_contracted) THEN
        result := 'BELOW_MINIMUM';
    ELSIF active_lives > COALESCE(contract_data.lives_maximum, contract_data.lives_contracted) THEN
        result := 'ABOVE_MAXIMUM';
    ELSE
        result := 'WITHIN_LIMITS';
    END IF;

    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Fun√ß√£o: Obter relat√≥rio mensal de vidas
CREATE OR REPLACE FUNCTION get_monthly_lives_report(
    p_contract_id INTEGER,
    p_year_month DATE
) RETURNS TABLE (
    person_id INTEGER,
    person_name VARCHAR,
    relationship_type VARCHAR,
    days_active INTEGER,
    start_date DATE,
    end_date DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        cl.person_id,
        p.name::VARCHAR as person_name,
        cl.relationship_type::VARCHAR,
        (LEAST(
            (p_year_month + INTERVAL '1 month' - INTERVAL '1 day')::DATE,
            COALESCE(cl.end_date, CURRENT_DATE)
        ) - GREATEST(cl.start_date, p_year_month) + 1)::INTEGER as days_active,
        cl.start_date,
        cl.end_date
    FROM contract_lives cl
    JOIN people p ON cl.person_id = p.id
    WHERE cl.contract_id = p_contract_id
      AND cl.start_date <= (p_year_month + INTERVAL '1 month' - INTERVAL '1 day')
      AND (cl.end_date IS NULL OR cl.end_date >= p_year_month)
    ORDER BY cl.start_date, p.name;
END;
$$ LANGUAGE plpgsql;
```

## üìà Dashboard de Controle

### **M√©tricas Importantes**

1. **Ocupa√ß√£o Atual**: 10/10 vidas (100%)
2. **Substitui√ß√µes no M√™s**: 2 trocas
3. **Hist√≥rico de Altera√ß√µes**: Timeline completo
4. **Faturamento**: Baseado em 10 vidas independente da ocupa√ß√£o real
5. **Alertas**: Quando sair dos limites de toler√¢ncia

### **Relat√≥rios Necess√°rios**

1. **Mensal**: Vidas ativas por contrato
2. **Hist√≥rico**: Todas as substitui√ß√µes e motivos
3. **Faturamento**: Controle de cobran√ßa por per√≠odo
4. **Auditoria**: Rastreabilidade completa de mudan√ßas

## üìä Dashboard de Gest√£o Home Care

### **M√©tricas Principais**

**1. Vis√£o Geral do Contrato**
- Ocupa√ß√£o de vidas: 8/10 (80%)
- Faturamento mensal: R$ 15.000,00
- Servi√ßos mais utilizados
- Score de qualidade m√©dio

**2. Controle de Servi√ßos por Vida**
- Utiliza√ß√£o mensal por categoria
- Alertas de limite (pr√≥ximo do m√°ximo)
- Autoriza√ß√µes pendentes
- Hist√≥rico de execu√ß√µes

**3. Qualidade e Satisfa√ß√£o**
- Score m√©dio por profissional
- Satisfa√ß√£o familiar por servi√ßo
- Tempo m√©dio de atendimento
- Taxa de n√£o comparecimento

**4. Financeiro**
- Faturamento por categoria de servi√ßo
- Receita por vida/m√™s
- Comparativo or√ßado vs realizado
- Proje√ß√£o de consumo

### **Relat√≥rios Automatizados**

**Relat√≥rio Mensal por Contrato:**
```sql
-- Relat√≥rio executivo mensal
SELECT
    c.contract_number,
    c.plan_name,
    COUNT(DISTINCT cl.id) as active_lives,
    c.lives_contracted,
    SUM(se.total_value) as monthly_revenue,
    AVG(se.quality_score) as avg_quality,
    COUNT(se.id) as total_services,

    -- Por categoria
    COUNT(CASE WHEN sc.service_category = 'ENFERMAGEM' THEN 1 END) as nursing_services,
    COUNT(CASE WHEN sc.service_category = 'FISIOTERAPIA' THEN 1 END) as physio_services,
    COUNT(CASE WHEN sc.service_category = 'MEDICINA' THEN 1 END) as medical_services

FROM contracts c
LEFT JOIN contract_lives cl ON c.id = cl.contract_id AND cl.status = 'ACTIVE'
LEFT JOIN service_executions se ON cl.id = se.contract_life_id
    AND DATE_TRUNC('month', se.execution_date) = DATE_TRUNC('month', CURRENT_DATE)
    AND se.status = 'EXECUTED'
LEFT JOIN services_catalog sc ON se.service_id = sc.id
WHERE c.status = 'ACTIVE'
GROUP BY c.id, c.contract_number, c.plan_name;
```

**Alerta de Limites:**
```sql
-- Vidas pr√≥ximas dos limites mensais
SELECT
    p.name as person_name,
    sc.service_name,
    COUNT(se.id) as used_this_month,
    avs.effective_monthly_limit as monthly_limit,
    ROUND((COUNT(se.id)::DECIMAL / avs.effective_monthly_limit) * 100, 1) as usage_percentage

FROM available_services_per_life avs
JOIN people p ON avs.person_name = p.name
JOIN services_catalog sc ON avs.service_code = sc.service_code
LEFT JOIN service_executions se ON avs.contract_life_id = se.contract_life_id
    AND avs.service_id = se.service_id
    AND DATE_TRUNC('month', se.execution_date) = DATE_TRUNC('month', CURRENT_DATE)
    AND se.status = 'EXECUTED'

WHERE avs.effective_monthly_limit IS NOT NULL
GROUP BY p.name, sc.service_name, avs.effective_monthly_limit
HAVING COUNT(se.id)::DECIMAL / avs.effective_monthly_limit >= 0.8  -- 80% do limite
ORDER BY usage_percentage DESC;
```

## üîß Integra√ß√£o com Sistema Atual

### **Mapeamento de Tabelas Existentes**

**Aproveitamento das tabelas atuais:**
- `clients` ‚Üí Mant√©m como est√° (PF/PJ)
- `people` ‚Üí Mant√©m como est√° (vidas individuais)
- `users` ‚Üí Mant√©m como est√° (profissionais)

**Novas tabelas necess√°rias:**
- `contracts` ‚Üí Nova (contratos por cliente)
- `contract_lives` ‚Üí Nova (vidas vinculadas)
- `services_catalog` ‚Üí Nova (cat√°logo de servi√ßos)
- `contract_services` ‚Üí Nova (servi√ßos do contrato)
- `contract_life_services` ‚Üí Nova (personaliza√ß√µes)
- `service_executions` ‚Üí Nova (hist√≥rico execu√ß√µes)

### **APIs Necess√°rias**

**1. Gest√£o de Contratos:**
- `POST /api/v1/contracts` - Criar contrato
- `GET /api/v1/contracts/{id}` - Detalhes do contrato
- `PUT /api/v1/contracts/{id}/lives` - Gerenciar vidas
- `GET /api/v1/contracts/{id}/services` - Servi√ßos dispon√≠veis

**2. Gest√£o de Servi√ßos:**
- `GET /api/v1/services/catalog` - Cat√°logo completo
- `POST /api/v1/services/executions` - Registrar execu√ß√£o
- `GET /api/v1/services/limits/{life_id}` - Verificar limites
- `POST /api/v1/services/authorize` - Autorizar servi√ßo

**3. Relat√≥rios:**
- `GET /api/v1/reports/contract/{id}/monthly` - Relat√≥rio mensal
- `GET /api/v1/reports/alerts/limits` - Alertas de limites
- `GET /api/v1/dashboard/contract/{id}` - Dashboard executivo

## üöÄ Roadmap de Implementa√ß√£o

### **Fase 1: Estrutura Base (2-3 semanas)**
1. ‚úÖ **An√°lise completa** (atual)
2. üîÑ **Cria√ß√£o das tabelas** de contratos e servi√ßos
3. üîÑ **APIs b√°sicas** de CRUD
4. üîÑ **Testes unit√°rios** das valida√ß√µes

### **Fase 2: Gest√£o de Servi√ßos (3-4 semanas)**
1. üîÑ **Cat√°logo de servi√ßos** completo
2. üîÑ **Sistema de autoriza√ß√µes** m√©dicas
3. üîÑ **Controle de limites** autom√°tico
4. üîÑ **Interface de execu√ß√£o** de servi√ßos

### **Fase 3: Relat√≥rios e Dashboard (2-3 semanas)**
1. üîÑ **Dashboard executivo** por contrato
2. üîÑ **Relat√≥rios autom√°ticos** mensais
3. üîÑ **Sistema de alertas** de limites
4. üîÑ **M√©tricas de qualidade** e satisfa√ß√£o

### **Fase 4: Integra√ß√£o e Testes (2-3 semanas)**
1. üîÑ **Migra√ß√£o de dados** existentes
2. üîÑ **Testes com UNIMED** (piloto)
3. üîÑ **Ajustes e otimiza√ß√µes**
4. üîÑ **Treinamento da equipe**

## ‚úÖ Benef√≠cios da Solu√ß√£o

### **Para a Empresa**
- ‚úÖ **Controle total** de contratos e servi√ßos
- ‚úÖ **Faturamento preciso** e autom√°tico
- ‚úÖ **Gest√£o de qualidade** integrada
- ‚úÖ **Hist√≥rico completo** para auditoria

### **Para os Clientes (UNIMED)**
- ‚úÖ **Flexibilidade** na troca de vidas
- ‚úÖ **Transpar√™ncia** no consumo de servi√ßos
- ‚úÖ **Relat√≥rios detalhados** mensais
- ‚úÖ **Controle de custos** previs√≠vel

### **Para as Vidas (Pacientes)**
- ‚úÖ **Servi√ßos personalizados** conforme necessidade m√©dica
- ‚úÖ **Qualidade assegurada** com m√©tricas
- ‚úÖ **Atendimento domiciliar** humanizado
- ‚úÖ **Acompanhamento cont√≠nuo** da sa√∫de

---

**Esta estrutura resolve completamente o desafio dos contratos home care com m√∫ltiplas vidas, oferecendo flexibilidade operacional com controle rigoroso financeiro e de qualidade.**
